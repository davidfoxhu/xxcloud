// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: realtime_push.proto

#ifndef PROTOBUF_realtime_5fpush_2eproto__INCLUDED
#define PROTOBUF_realtime_5fpush_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "pbrpc.pb.h"
#include "regist_condition.pb.h"
// @@protoc_insertion_point(includes)

namespace lbs {
namespace da {
namespace openservice {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_realtime_5fpush_2eproto();
void protobuf_AssignDesc_realtime_5fpush_2eproto();
void protobuf_ShutdownFile_realtime_5fpush_2eproto();

class PoiInfo;
class AoiInfo;
class TrajStatusInfo;
class UserTriggeredInfo;
class GetPushDetailRequest;
class RedisKeyVal;
class MsgCenterPushInfo;
class MsgCenterPushDetail;
class GetPushDetailResponse;

enum PushActionType {
  NO_ACTION = 1,
  WRITE_REDIS = 2,
  PUSH_MSGCENTER = 3,
  WRITE_REDIS_PUSH_MSGCENTER = 4
};
bool PushActionType_IsValid(int value);
const PushActionType PushActionType_MIN = NO_ACTION;
const PushActionType PushActionType_MAX = WRITE_REDIS_PUSH_MSGCENTER;
const int PushActionType_ARRAYSIZE = PushActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PushActionType_descriptor();
inline const ::std::string& PushActionType_Name(PushActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PushActionType_descriptor(), value);
}
inline bool PushActionType_Parse(
    const ::std::string& name, PushActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PushActionType>(
    PushActionType_descriptor(), name, value);
}
// ===================================================================

class PoiInfo : public ::google::protobuf::Message {
 public:
  PoiInfo();
  virtual ~PoiInfo();
  
  PoiInfo(const PoiInfo& from);
  
  inline PoiInfo& operator=(const PoiInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PoiInfo& default_instance();
  
  void Swap(PoiInfo* other);
  
  // implements Message ----------------------------------------------
  
  PoiInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoiInfo& from);
  void MergeFrom(const PoiInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string poi_id = 1;
  inline bool has_poi_id() const;
  inline void clear_poi_id();
  static const int kPoiIdFieldNumber = 1;
  inline const ::std::string& poi_id() const;
  inline void set_poi_id(const ::std::string& value);
  inline void set_poi_id(const char* value);
  inline void set_poi_id(const char* value, size_t size);
  inline ::std::string* mutable_poi_id();
  inline ::std::string* release_poi_id();
  
  // optional double poi_x = 2;
  inline bool has_poi_x() const;
  inline void clear_poi_x();
  static const int kPoiXFieldNumber = 2;
  inline double poi_x() const;
  inline void set_poi_x(double value);
  
  // optional double poi_y = 3;
  inline bool has_poi_y() const;
  inline void clear_poi_y();
  static const int kPoiYFieldNumber = 3;
  inline double poi_y() const;
  inline void set_poi_y(double value);
  
  // optional double poi_r = 4;
  inline bool has_poi_r() const;
  inline void clear_poi_r();
  static const int kPoiRFieldNumber = 4;
  inline double poi_r() const;
  inline void set_poi_r(double value);
  
  // optional string poi_tag = 5;
  inline bool has_poi_tag() const;
  inline void clear_poi_tag();
  static const int kPoiTagFieldNumber = 5;
  inline const ::std::string& poi_tag() const;
  inline void set_poi_tag(const ::std::string& value);
  inline void set_poi_tag(const char* value);
  inline void set_poi_tag(const char* value, size_t size);
  inline ::std::string* mutable_poi_tag();
  inline ::std::string* release_poi_tag();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.PoiInfo)
 private:
  inline void set_has_poi_id();
  inline void clear_has_poi_id();
  inline void set_has_poi_x();
  inline void clear_has_poi_x();
  inline void set_has_poi_y();
  inline void clear_has_poi_y();
  inline void set_has_poi_r();
  inline void clear_has_poi_r();
  inline void set_has_poi_tag();
  inline void clear_has_poi_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* poi_id_;
  double poi_x_;
  double poi_y_;
  double poi_r_;
  ::std::string* poi_tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static PoiInfo* default_instance_;
};
// -------------------------------------------------------------------

class AoiInfo : public ::google::protobuf::Message {
 public:
  AoiInfo();
  virtual ~AoiInfo();
  
  AoiInfo(const AoiInfo& from);
  
  inline AoiInfo& operator=(const AoiInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AoiInfo& default_instance();
  
  void Swap(AoiInfo* other);
  
  // implements Message ----------------------------------------------
  
  AoiInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AoiInfo& from);
  void MergeFrom(const AoiInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string aoi_id = 1;
  inline bool has_aoi_id() const;
  inline void clear_aoi_id();
  static const int kAoiIdFieldNumber = 1;
  inline const ::std::string& aoi_id() const;
  inline void set_aoi_id(const ::std::string& value);
  inline void set_aoi_id(const char* value);
  inline void set_aoi_id(const char* value, size_t size);
  inline ::std::string* mutable_aoi_id();
  inline ::std::string* release_aoi_id();
  
  // optional string aoi_tag = 2;
  inline bool has_aoi_tag() const;
  inline void clear_aoi_tag();
  static const int kAoiTagFieldNumber = 2;
  inline const ::std::string& aoi_tag() const;
  inline void set_aoi_tag(const ::std::string& value);
  inline void set_aoi_tag(const char* value);
  inline void set_aoi_tag(const char* value, size_t size);
  inline ::std::string* mutable_aoi_tag();
  inline ::std::string* release_aoi_tag();
  
  // optional string aoi_name = 3;
  inline bool has_aoi_name() const;
  inline void clear_aoi_name();
  static const int kAoiNameFieldNumber = 3;
  inline const ::std::string& aoi_name() const;
  inline void set_aoi_name(const ::std::string& value);
  inline void set_aoi_name(const char* value);
  inline void set_aoi_name(const char* value, size_t size);
  inline ::std::string* mutable_aoi_name();
  inline ::std::string* release_aoi_name();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.AoiInfo)
 private:
  inline void set_has_aoi_id();
  inline void clear_has_aoi_id();
  inline void set_has_aoi_tag();
  inline void clear_has_aoi_tag();
  inline void set_has_aoi_name();
  inline void clear_has_aoi_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* aoi_id_;
  ::std::string* aoi_tag_;
  ::std::string* aoi_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static AoiInfo* default_instance_;
};
// -------------------------------------------------------------------

class TrajStatusInfo : public ::google::protobuf::Message {
 public:
  TrajStatusInfo();
  virtual ~TrajStatusInfo();
  
  TrajStatusInfo(const TrajStatusInfo& from);
  
  inline TrajStatusInfo& operator=(const TrajStatusInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajStatusInfo& default_instance();
  
  void Swap(TrajStatusInfo* other);
  
  // implements Message ----------------------------------------------
  
  TrajStatusInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrajStatusInfo& from);
  void MergeFrom(const TrajStatusInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .lbs.da.openservice.UserTrajStatus traj_status = 1;
  inline bool has_traj_status() const;
  inline void clear_traj_status();
  static const int kTrajStatusFieldNumber = 1;
  inline lbs::da::openservice::UserTrajStatus traj_status() const;
  inline void set_traj_status(lbs::da::openservice::UserTrajStatus value);
  
  // optional double mercator_x = 2;
  inline bool has_mercator_x() const;
  inline void clear_mercator_x();
  static const int kMercatorXFieldNumber = 2;
  inline double mercator_x() const;
  inline void set_mercator_x(double value);
  
  // optional double mercator_y = 3;
  inline bool has_mercator_y() const;
  inline void clear_mercator_y();
  static const int kMercatorYFieldNumber = 3;
  inline double mercator_y() const;
  inline void set_mercator_y(double value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.TrajStatusInfo)
 private:
  inline void set_has_traj_status();
  inline void clear_has_traj_status();
  inline void set_has_mercator_x();
  inline void clear_has_mercator_x();
  inline void set_has_mercator_y();
  inline void clear_has_mercator_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double mercator_x_;
  double mercator_y_;
  int traj_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static TrajStatusInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserTriggeredInfo : public ::google::protobuf::Message {
 public:
  UserTriggeredInfo();
  virtual ~UserTriggeredInfo();
  
  UserTriggeredInfo(const UserTriggeredInfo& from);
  
  inline UserTriggeredInfo& operator=(const UserTriggeredInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTriggeredInfo& default_instance();
  
  void Swap(UserTriggeredInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserTriggeredInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserTriggeredInfo& from);
  void MergeFrom(const UserTriggeredInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string cuid = 1;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 1;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional string passport_id = 2;
  inline bool has_passport_id() const;
  inline void clear_passport_id();
  static const int kPassportIdFieldNumber = 2;
  inline const ::std::string& passport_id() const;
  inline void set_passport_id(const ::std::string& value);
  inline void set_passport_id(const char* value);
  inline void set_passport_id(const char* value, size_t size);
  inline ::std::string* mutable_passport_id();
  inline ::std::string* release_passport_id();
  
  // optional double mercator_x = 3;
  inline bool has_mercator_x() const;
  inline void clear_mercator_x();
  static const int kMercatorXFieldNumber = 3;
  inline double mercator_x() const;
  inline void set_mercator_x(double value);
  
  // optional double mercator_y = 4;
  inline bool has_mercator_y() const;
  inline void clear_mercator_y();
  static const int kMercatorYFieldNumber = 4;
  inline double mercator_y() const;
  inline void set_mercator_y(double value);
  
  // optional string tsmcid = 5;
  inline bool has_tsmcid() const;
  inline void clear_tsmcid();
  static const int kTsmcidFieldNumber = 5;
  inline const ::std::string& tsmcid() const;
  inline void set_tsmcid(const ::std::string& value);
  inline void set_tsmcid(const char* value);
  inline void set_tsmcid(const char* value, size_t size);
  inline ::std::string* mutable_tsmcid();
  inline ::std::string* release_tsmcid();
  
  // optional int64 last_log_time = 6;
  inline bool has_last_log_time() const;
  inline void clear_last_log_time();
  static const int kLastLogTimeFieldNumber = 6;
  inline ::google::protobuf::int64 last_log_time() const;
  inline void set_last_log_time(::google::protobuf::int64 value);
  
  // optional int64 target_city = 7;
  inline bool has_target_city() const;
  inline void clear_target_city();
  static const int kTargetCityFieldNumber = 7;
  inline ::google::protobuf::int64 target_city() const;
  inline void set_target_city(::google::protobuf::int64 value);
  
  // optional string cond_id = 8;
  inline bool has_cond_id() const;
  inline void clear_cond_id();
  static const int kCondIdFieldNumber = 8;
  inline const ::std::string& cond_id() const;
  inline void set_cond_id(const ::std::string& value);
  inline void set_cond_id(const char* value);
  inline void set_cond_id(const char* value, size_t size);
  inline ::std::string* mutable_cond_id();
  inline ::std::string* release_cond_id();
  
  // optional string cond_tag = 9;
  inline bool has_cond_tag() const;
  inline void clear_cond_tag();
  static const int kCondTagFieldNumber = 9;
  inline const ::std::string& cond_tag() const;
  inline void set_cond_tag(const ::std::string& value);
  inline void set_cond_tag(const char* value);
  inline void set_cond_tag(const char* value, size_t size);
  inline ::std::string* mutable_cond_tag();
  inline ::std::string* release_cond_tag();
  
  // optional string append = 10;
  inline bool has_append() const;
  inline void clear_append();
  static const int kAppendFieldNumber = 10;
  inline const ::std::string& append() const;
  inline void set_append(const ::std::string& value);
  inline void set_append(const char* value);
  inline void set_append(const char* value, size_t size);
  inline ::std::string* mutable_append();
  inline ::std::string* release_append();
  
  // repeated .lbs.da.openservice.PoiInfo triggered_poi = 11;
  inline int triggered_poi_size() const;
  inline void clear_triggered_poi();
  static const int kTriggeredPoiFieldNumber = 11;
  inline const ::lbs::da::openservice::PoiInfo& triggered_poi(int index) const;
  inline ::lbs::da::openservice::PoiInfo* mutable_triggered_poi(int index);
  inline ::lbs::da::openservice::PoiInfo* add_triggered_poi();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >&
      triggered_poi() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >*
      mutable_triggered_poi();
  
  // repeated .lbs.da.openservice.AoiInfo triggered_aoi = 12;
  inline int triggered_aoi_size() const;
  inline void clear_triggered_aoi();
  static const int kTriggeredAoiFieldNumber = 12;
  inline const ::lbs::da::openservice::AoiInfo& triggered_aoi(int index) const;
  inline ::lbs::da::openservice::AoiInfo* mutable_triggered_aoi(int index);
  inline ::lbs::da::openservice::AoiInfo* add_triggered_aoi();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::AoiInfo >&
      triggered_aoi() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::AoiInfo >*
      mutable_triggered_aoi();
  
  // optional .lbs.da.openservice.TrajStatusInfo triggered_status = 13;
  inline bool has_triggered_status() const;
  inline void clear_triggered_status();
  static const int kTriggeredStatusFieldNumber = 13;
  inline const ::lbs::da::openservice::TrajStatusInfo& triggered_status() const;
  inline ::lbs::da::openservice::TrajStatusInfo* mutable_triggered_status();
  inline ::lbs::da::openservice::TrajStatusInfo* release_triggered_status();
  
  // repeated .lbs.da.openservice.Rule triggered_rules = 14;
  inline int triggered_rules_size() const;
  inline void clear_triggered_rules();
  static const int kTriggeredRulesFieldNumber = 14;
  inline const ::lbs::da::openservice::Rule& triggered_rules(int index) const;
  inline ::lbs::da::openservice::Rule* mutable_triggered_rules(int index);
  inline ::lbs::da::openservice::Rule* add_triggered_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >&
      triggered_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >*
      mutable_triggered_rules();
  
  // optional string os_name = 15;
  inline bool has_os_name() const;
  inline void clear_os_name();
  static const int kOsNameFieldNumber = 15;
  inline const ::std::string& os_name() const;
  inline void set_os_name(const ::std::string& value);
  inline void set_os_name(const char* value);
  inline void set_os_name(const char* value, size_t size);
  inline ::std::string* mutable_os_name();
  inline ::std::string* release_os_name();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.UserTriggeredInfo)
 private:
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_passport_id();
  inline void clear_has_passport_id();
  inline void set_has_mercator_x();
  inline void clear_has_mercator_x();
  inline void set_has_mercator_y();
  inline void clear_has_mercator_y();
  inline void set_has_tsmcid();
  inline void clear_has_tsmcid();
  inline void set_has_last_log_time();
  inline void clear_has_last_log_time();
  inline void set_has_target_city();
  inline void clear_has_target_city();
  inline void set_has_cond_id();
  inline void clear_has_cond_id();
  inline void set_has_cond_tag();
  inline void clear_has_cond_tag();
  inline void set_has_append();
  inline void clear_has_append();
  inline void set_has_triggered_status();
  inline void clear_has_triggered_status();
  inline void set_has_os_name();
  inline void clear_has_os_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cuid_;
  ::std::string* passport_id_;
  double mercator_x_;
  double mercator_y_;
  ::std::string* tsmcid_;
  ::google::protobuf::int64 last_log_time_;
  ::google::protobuf::int64 target_city_;
  ::std::string* cond_id_;
  ::std::string* cond_tag_;
  ::std::string* append_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo > triggered_poi_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::AoiInfo > triggered_aoi_;
  ::lbs::da::openservice::TrajStatusInfo* triggered_status_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule > triggered_rules_;
  ::std::string* os_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static UserTriggeredInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetPushDetailRequest : public ::google::protobuf::Message {
 public:
  GetPushDetailRequest();
  virtual ~GetPushDetailRequest();
  
  GetPushDetailRequest(const GetPushDetailRequest& from);
  
  inline GetPushDetailRequest& operator=(const GetPushDetailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPushDetailRequest& default_instance();
  
  void Swap(GetPushDetailRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetPushDetailRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPushDetailRequest& from);
  void MergeFrom(const GetPushDetailRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // optional string cuid = 2;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 2;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional string passport_id = 3;
  inline bool has_passport_id() const;
  inline void clear_passport_id();
  static const int kPassportIdFieldNumber = 3;
  inline const ::std::string& passport_id() const;
  inline void set_passport_id(const ::std::string& value);
  inline void set_passport_id(const char* value);
  inline void set_passport_id(const char* value, size_t size);
  inline ::std::string* mutable_passport_id();
  inline ::std::string* release_passport_id();
  
  // optional string cond_tag = 4;
  inline bool has_cond_tag() const;
  inline void clear_cond_tag();
  static const int kCondTagFieldNumber = 4;
  inline const ::std::string& cond_tag() const;
  inline void set_cond_tag(const ::std::string& value);
  inline void set_cond_tag(const char* value);
  inline void set_cond_tag(const char* value, size_t size);
  inline ::std::string* mutable_cond_tag();
  inline ::std::string* release_cond_tag();
  
  // optional .lbs.da.openservice.UserTriggeredInfo triggered_info = 5;
  inline bool has_triggered_info() const;
  inline void clear_triggered_info();
  static const int kTriggeredInfoFieldNumber = 5;
  inline const ::lbs::da::openservice::UserTriggeredInfo& triggered_info() const;
  inline ::lbs::da::openservice::UserTriggeredInfo* mutable_triggered_info();
  inline ::lbs::da::openservice::UserTriggeredInfo* release_triggered_info();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetPushDetailRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_passport_id();
  inline void clear_has_passport_id();
  inline void set_has_cond_tag();
  inline void clear_has_cond_tag();
  inline void set_has_triggered_info();
  inline void clear_has_triggered_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* cuid_;
  ::std::string* passport_id_;
  ::std::string* cond_tag_;
  ::lbs::da::openservice::UserTriggeredInfo* triggered_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static GetPushDetailRequest* default_instance_;
};
// -------------------------------------------------------------------

class RedisKeyVal : public ::google::protobuf::Message {
 public:
  RedisKeyVal();
  virtual ~RedisKeyVal();
  
  RedisKeyVal(const RedisKeyVal& from);
  
  inline RedisKeyVal& operator=(const RedisKeyVal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedisKeyVal& default_instance();
  
  void Swap(RedisKeyVal* other);
  
  // implements Message ----------------------------------------------
  
  RedisKeyVal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RedisKeyVal& from);
  void MergeFrom(const RedisKeyVal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  
  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional string val = 3;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 3;
  inline const ::std::string& val() const;
  inline void set_val(const ::std::string& value);
  inline void set_val(const char* value);
  inline void set_val(const char* value, size_t size);
  inline ::std::string* mutable_val();
  inline ::std::string* release_val();
  
  // optional int64 expire_seconds = 4;
  inline bool has_expire_seconds() const;
  inline void clear_expire_seconds();
  static const int kExpireSecondsFieldNumber = 4;
  inline ::google::protobuf::int64 expire_seconds() const;
  inline void set_expire_seconds(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.RedisKeyVal)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();
  inline void set_has_expire_seconds();
  inline void clear_has_expire_seconds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* source_;
  ::std::string* key_;
  ::std::string* val_;
  ::google::protobuf::int64 expire_seconds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static RedisKeyVal* default_instance_;
};
// -------------------------------------------------------------------

class MsgCenterPushInfo : public ::google::protobuf::Message {
 public:
  MsgCenterPushInfo();
  virtual ~MsgCenterPushInfo();
  
  MsgCenterPushInfo(const MsgCenterPushInfo& from);
  
  inline MsgCenterPushInfo& operator=(const MsgCenterPushInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCenterPushInfo& default_instance();
  
  void Swap(MsgCenterPushInfo* other);
  
  // implements Message ----------------------------------------------
  
  MsgCenterPushInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCenterPushInfo& from);
  void MergeFrom(const MsgCenterPushInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 tuanid = 1;
  inline bool has_tuanid() const;
  inline void clear_tuanid();
  static const int kTuanidFieldNumber = 1;
  inline ::google::protobuf::int32 tuanid() const;
  inline void set_tuanid(::google::protobuf::int32 value);
  
  // optional int32 situationid = 2;
  inline bool has_situationid() const;
  inline void clear_situationid();
  static const int kSituationidFieldNumber = 2;
  inline ::google::protobuf::int32 situationid() const;
  inline void set_situationid(::google::protobuf::int32 value);
  
  // optional int32 startday = 3;
  inline bool has_startday() const;
  inline void clear_startday();
  static const int kStartdayFieldNumber = 3;
  inline ::google::protobuf::int32 startday() const;
  inline void set_startday(::google::protobuf::int32 value);
  
  // optional int32 daysize = 4;
  inline bool has_daysize() const;
  inline void clear_daysize();
  static const int kDaysizeFieldNumber = 4;
  inline ::google::protobuf::int32 daysize() const;
  inline void set_daysize(::google::protobuf::int32 value);
  
  // optional int32 dealsize = 5;
  inline bool has_dealsize() const;
  inline void clear_dealsize();
  static const int kDealsizeFieldNumber = 5;
  inline ::google::protobuf::int32 dealsize() const;
  inline void set_dealsize(::google::protobuf::int32 value);
  
  // optional int32 strsitelist = 6;
  inline bool has_strsitelist() const;
  inline void clear_strsitelist();
  static const int kStrsitelistFieldNumber = 6;
  inline ::google::protobuf::int32 strsitelist() const;
  inline void set_strsitelist(::google::protobuf::int32 value);
  
  // optional int32 eventid = 7;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventidFieldNumber = 7;
  inline ::google::protobuf::int32 eventid() const;
  inline void set_eventid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.MsgCenterPushInfo)
 private:
  inline void set_has_tuanid();
  inline void clear_has_tuanid();
  inline void set_has_situationid();
  inline void clear_has_situationid();
  inline void set_has_startday();
  inline void clear_has_startday();
  inline void set_has_daysize();
  inline void clear_has_daysize();
  inline void set_has_dealsize();
  inline void clear_has_dealsize();
  inline void set_has_strsitelist();
  inline void clear_has_strsitelist();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tuanid_;
  ::google::protobuf::int32 situationid_;
  ::google::protobuf::int32 startday_;
  ::google::protobuf::int32 daysize_;
  ::google::protobuf::int32 dealsize_;
  ::google::protobuf::int32 strsitelist_;
  ::google::protobuf::int32 eventid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static MsgCenterPushInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgCenterPushDetail : public ::google::protobuf::Message {
 public:
  MsgCenterPushDetail();
  virtual ~MsgCenterPushDetail();
  
  MsgCenterPushDetail(const MsgCenterPushDetail& from);
  
  inline MsgCenterPushDetail& operator=(const MsgCenterPushDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCenterPushDetail& default_instance();
  
  void Swap(MsgCenterPushDetail* other);
  
  // implements Message ----------------------------------------------
  
  MsgCenterPushDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCenterPushDetail& from);
  void MergeFrom(const MsgCenterPushDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  
  // optional int32 utype = 2;
  inline bool has_utype() const;
  inline void clear_utype();
  static const int kUtypeFieldNumber = 2;
  inline ::google::protobuf::int32 utype() const;
  inline void set_utype(::google::protobuf::int32 value);
  
  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional string title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional string content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // optional int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional int32 prod = 7 [default = 1];
  inline bool has_prod() const;
  inline void clear_prod();
  static const int kProdFieldNumber = 7;
  inline ::google::protobuf::int32 prod() const;
  inline void set_prod(::google::protobuf::int32 value);
  
  // optional string operator = 8;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 8;
  inline const ::std::string& operator_() const;
  inline void set_operator_(const ::std::string& value);
  inline void set_operator_(const char* value);
  inline void set_operator_(const char* value, size_t size);
  inline ::std::string* mutable_operator_();
  inline ::std::string* release_operator_();
  
  // optional string src = 9 [default = "srh"];
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 9;
  inline const ::std::string& src() const;
  inline void set_src(const ::std::string& value);
  inline void set_src(const char* value);
  inline void set_src(const char* value, size_t size);
  inline ::std::string* mutable_src();
  inline ::std::string* release_src();
  
  // optional int32 at = 10 [default = 0];
  inline bool has_at() const;
  inline void clear_at();
  static const int kAtFieldNumber = 10;
  inline ::google::protobuf::int32 at() const;
  inline void set_at(::google::protobuf::int32 value);
  
  // optional int32 seq = 11 [default = -1];
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 11;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);
  
  // optional int32 et = 12 [default = 0];
  inline bool has_et() const;
  inline void clear_et();
  static const int kEtFieldNumber = 12;
  inline ::google::protobuf::int32 et() const;
  inline void set_et(::google::protobuf::int32 value);
  
  // optional int32 exp = 13;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 13;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);
  
  // optional .lbs.da.openservice.MsgCenterPushInfo info = 14;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 14;
  inline const ::lbs::da::openservice::MsgCenterPushInfo& info() const;
  inline ::lbs::da::openservice::MsgCenterPushInfo* mutable_info();
  inline ::lbs::da::openservice::MsgCenterPushInfo* release_info();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.MsgCenterPushDetail)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_utype();
  inline void clear_has_utype();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_prod();
  inline void clear_has_prod();
  inline void set_has_operator_();
  inline void clear_has_operator_();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_at();
  inline void clear_has_at();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_et();
  inline void clear_has_et();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_info();
  inline void clear_has_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pid_;
  ::std::string* uid_;
  ::std::string* title_;
  ::google::protobuf::int32 utype_;
  ::google::protobuf::int32 type_;
  ::std::string* content_;
  ::std::string* operator__;
  ::google::protobuf::int32 prod_;
  ::google::protobuf::int32 at_;
  ::std::string* src_;
  static const ::std::string _default_src_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::int32 et_;
  ::lbs::da::openservice::MsgCenterPushInfo* info_;
  ::google::protobuf::int32 exp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static MsgCenterPushDetail* default_instance_;
};
// -------------------------------------------------------------------

class GetPushDetailResponse : public ::google::protobuf::Message {
 public:
  GetPushDetailResponse();
  virtual ~GetPushDetailResponse();
  
  GetPushDetailResponse(const GetPushDetailResponse& from);
  
  inline GetPushDetailResponse& operator=(const GetPushDetailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPushDetailResponse& default_instance();
  
  void Swap(GetPushDetailResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetPushDetailResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPushDetailResponse& from);
  void MergeFrom(const GetPushDetailResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string trigger_cond_id = 1;
  inline bool has_trigger_cond_id() const;
  inline void clear_trigger_cond_id();
  static const int kTriggerCondIdFieldNumber = 1;
  inline const ::std::string& trigger_cond_id() const;
  inline void set_trigger_cond_id(const ::std::string& value);
  inline void set_trigger_cond_id(const char* value);
  inline void set_trigger_cond_id(const char* value, size_t size);
  inline ::std::string* mutable_trigger_cond_id();
  inline ::std::string* release_trigger_cond_id();
  
  // optional string cuid = 2;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 2;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional string passport_id = 3;
  inline bool has_passport_id() const;
  inline void clear_passport_id();
  static const int kPassportIdFieldNumber = 3;
  inline const ::std::string& passport_id() const;
  inline void set_passport_id(const ::std::string& value);
  inline void set_passport_id(const char* value);
  inline void set_passport_id(const char* value, size_t size);
  inline ::std::string* mutable_passport_id();
  inline ::std::string* release_passport_id();
  
  // repeated .lbs.da.openservice.RedisKeyVal redis_data = 5;
  inline int redis_data_size() const;
  inline void clear_redis_data();
  static const int kRedisDataFieldNumber = 5;
  inline const ::lbs::da::openservice::RedisKeyVal& redis_data(int index) const;
  inline ::lbs::da::openservice::RedisKeyVal* mutable_redis_data(int index);
  inline ::lbs::da::openservice::RedisKeyVal* add_redis_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RedisKeyVal >&
      redis_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RedisKeyVal >*
      mutable_redis_data();
  
  // optional .lbs.da.openservice.MsgCenterPushDetail push_detail = 6;
  inline bool has_push_detail() const;
  inline void clear_push_detail();
  static const int kPushDetailFieldNumber = 6;
  inline const ::lbs::da::openservice::MsgCenterPushDetail& push_detail() const;
  inline ::lbs::da::openservice::MsgCenterPushDetail* mutable_push_detail();
  inline ::lbs::da::openservice::MsgCenterPushDetail* release_push_detail();
  
  // optional string sample_ids = 7;
  inline bool has_sample_ids() const;
  inline void clear_sample_ids();
  static const int kSampleIdsFieldNumber = 7;
  inline const ::std::string& sample_ids() const;
  inline void set_sample_ids(const ::std::string& value);
  inline void set_sample_ids(const char* value);
  inline void set_sample_ids(const char* value, size_t size);
  inline ::std::string* mutable_sample_ids();
  inline ::std::string* release_sample_ids();
  
  // optional .lbs.da.openservice.PushActionType action_type = 8;
  inline bool has_action_type() const;
  inline void clear_action_type();
  static const int kActionTypeFieldNumber = 8;
  inline lbs::da::openservice::PushActionType action_type() const;
  inline void set_action_type(lbs::da::openservice::PushActionType value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetPushDetailResponse)
 private:
  inline void set_has_trigger_cond_id();
  inline void clear_has_trigger_cond_id();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_passport_id();
  inline void clear_has_passport_id();
  inline void set_has_push_detail();
  inline void clear_has_push_detail();
  inline void set_has_sample_ids();
  inline void clear_has_sample_ids();
  inline void set_has_action_type();
  inline void clear_has_action_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* trigger_cond_id_;
  ::std::string* cuid_;
  ::std::string* passport_id_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RedisKeyVal > redis_data_;
  ::lbs::da::openservice::MsgCenterPushDetail* push_detail_;
  ::std::string* sample_ids_;
  int action_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_realtime_5fpush_2eproto();
  friend void protobuf_AssignDesc_realtime_5fpush_2eproto();
  friend void protobuf_ShutdownFile_realtime_5fpush_2eproto();
  
  void InitAsDefaultInstance();
  static GetPushDetailResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// PoiInfo

// optional string poi_id = 1;
inline bool PoiInfo::has_poi_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoiInfo::set_has_poi_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoiInfo::clear_has_poi_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoiInfo::clear_poi_id() {
  if (poi_id_ != &::google::protobuf::internal::kEmptyString) {
    poi_id_->clear();
  }
  clear_has_poi_id();
}
inline const ::std::string& PoiInfo::poi_id() const {
  return *poi_id_;
}
inline void PoiInfo::set_poi_id(const ::std::string& value) {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  poi_id_->assign(value);
}
inline void PoiInfo::set_poi_id(const char* value) {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  poi_id_->assign(value);
}
inline void PoiInfo::set_poi_id(const char* value, size_t size) {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  poi_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiInfo::mutable_poi_id() {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  return poi_id_;
}
inline ::std::string* PoiInfo::release_poi_id() {
  clear_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_id_;
    poi_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double poi_x = 2;
inline bool PoiInfo::has_poi_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoiInfo::set_has_poi_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoiInfo::clear_has_poi_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoiInfo::clear_poi_x() {
  poi_x_ = 0;
  clear_has_poi_x();
}
inline double PoiInfo::poi_x() const {
  return poi_x_;
}
inline void PoiInfo::set_poi_x(double value) {
  set_has_poi_x();
  poi_x_ = value;
}

// optional double poi_y = 3;
inline bool PoiInfo::has_poi_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoiInfo::set_has_poi_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoiInfo::clear_has_poi_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoiInfo::clear_poi_y() {
  poi_y_ = 0;
  clear_has_poi_y();
}
inline double PoiInfo::poi_y() const {
  return poi_y_;
}
inline void PoiInfo::set_poi_y(double value) {
  set_has_poi_y();
  poi_y_ = value;
}

// optional double poi_r = 4;
inline bool PoiInfo::has_poi_r() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoiInfo::set_has_poi_r() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoiInfo::clear_has_poi_r() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoiInfo::clear_poi_r() {
  poi_r_ = 0;
  clear_has_poi_r();
}
inline double PoiInfo::poi_r() const {
  return poi_r_;
}
inline void PoiInfo::set_poi_r(double value) {
  set_has_poi_r();
  poi_r_ = value;
}

// optional string poi_tag = 5;
inline bool PoiInfo::has_poi_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PoiInfo::set_has_poi_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PoiInfo::clear_has_poi_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PoiInfo::clear_poi_tag() {
  if (poi_tag_ != &::google::protobuf::internal::kEmptyString) {
    poi_tag_->clear();
  }
  clear_has_poi_tag();
}
inline const ::std::string& PoiInfo::poi_tag() const {
  return *poi_tag_;
}
inline void PoiInfo::set_poi_tag(const ::std::string& value) {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  poi_tag_->assign(value);
}
inline void PoiInfo::set_poi_tag(const char* value) {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  poi_tag_->assign(value);
}
inline void PoiInfo::set_poi_tag(const char* value, size_t size) {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  poi_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiInfo::mutable_poi_tag() {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  return poi_tag_;
}
inline ::std::string* PoiInfo::release_poi_tag() {
  clear_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_tag_;
    poi_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AoiInfo

// optional string aoi_id = 1;
inline bool AoiInfo::has_aoi_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AoiInfo::set_has_aoi_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AoiInfo::clear_has_aoi_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AoiInfo::clear_aoi_id() {
  if (aoi_id_ != &::google::protobuf::internal::kEmptyString) {
    aoi_id_->clear();
  }
  clear_has_aoi_id();
}
inline const ::std::string& AoiInfo::aoi_id() const {
  return *aoi_id_;
}
inline void AoiInfo::set_aoi_id(const ::std::string& value) {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  aoi_id_->assign(value);
}
inline void AoiInfo::set_aoi_id(const char* value) {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  aoi_id_->assign(value);
}
inline void AoiInfo::set_aoi_id(const char* value, size_t size) {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  aoi_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AoiInfo::mutable_aoi_id() {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  return aoi_id_;
}
inline ::std::string* AoiInfo::release_aoi_id() {
  clear_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aoi_id_;
    aoi_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string aoi_tag = 2;
inline bool AoiInfo::has_aoi_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AoiInfo::set_has_aoi_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AoiInfo::clear_has_aoi_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AoiInfo::clear_aoi_tag() {
  if (aoi_tag_ != &::google::protobuf::internal::kEmptyString) {
    aoi_tag_->clear();
  }
  clear_has_aoi_tag();
}
inline const ::std::string& AoiInfo::aoi_tag() const {
  return *aoi_tag_;
}
inline void AoiInfo::set_aoi_tag(const ::std::string& value) {
  set_has_aoi_tag();
  if (aoi_tag_ == &::google::protobuf::internal::kEmptyString) {
    aoi_tag_ = new ::std::string;
  }
  aoi_tag_->assign(value);
}
inline void AoiInfo::set_aoi_tag(const char* value) {
  set_has_aoi_tag();
  if (aoi_tag_ == &::google::protobuf::internal::kEmptyString) {
    aoi_tag_ = new ::std::string;
  }
  aoi_tag_->assign(value);
}
inline void AoiInfo::set_aoi_tag(const char* value, size_t size) {
  set_has_aoi_tag();
  if (aoi_tag_ == &::google::protobuf::internal::kEmptyString) {
    aoi_tag_ = new ::std::string;
  }
  aoi_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AoiInfo::mutable_aoi_tag() {
  set_has_aoi_tag();
  if (aoi_tag_ == &::google::protobuf::internal::kEmptyString) {
    aoi_tag_ = new ::std::string;
  }
  return aoi_tag_;
}
inline ::std::string* AoiInfo::release_aoi_tag() {
  clear_has_aoi_tag();
  if (aoi_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aoi_tag_;
    aoi_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string aoi_name = 3;
inline bool AoiInfo::has_aoi_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AoiInfo::set_has_aoi_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AoiInfo::clear_has_aoi_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AoiInfo::clear_aoi_name() {
  if (aoi_name_ != &::google::protobuf::internal::kEmptyString) {
    aoi_name_->clear();
  }
  clear_has_aoi_name();
}
inline const ::std::string& AoiInfo::aoi_name() const {
  return *aoi_name_;
}
inline void AoiInfo::set_aoi_name(const ::std::string& value) {
  set_has_aoi_name();
  if (aoi_name_ == &::google::protobuf::internal::kEmptyString) {
    aoi_name_ = new ::std::string;
  }
  aoi_name_->assign(value);
}
inline void AoiInfo::set_aoi_name(const char* value) {
  set_has_aoi_name();
  if (aoi_name_ == &::google::protobuf::internal::kEmptyString) {
    aoi_name_ = new ::std::string;
  }
  aoi_name_->assign(value);
}
inline void AoiInfo::set_aoi_name(const char* value, size_t size) {
  set_has_aoi_name();
  if (aoi_name_ == &::google::protobuf::internal::kEmptyString) {
    aoi_name_ = new ::std::string;
  }
  aoi_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AoiInfo::mutable_aoi_name() {
  set_has_aoi_name();
  if (aoi_name_ == &::google::protobuf::internal::kEmptyString) {
    aoi_name_ = new ::std::string;
  }
  return aoi_name_;
}
inline ::std::string* AoiInfo::release_aoi_name() {
  clear_has_aoi_name();
  if (aoi_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aoi_name_;
    aoi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TrajStatusInfo

// optional .lbs.da.openservice.UserTrajStatus traj_status = 1;
inline bool TrajStatusInfo::has_traj_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrajStatusInfo::set_has_traj_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrajStatusInfo::clear_has_traj_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrajStatusInfo::clear_traj_status() {
  traj_status_ = 0;
  clear_has_traj_status();
}
inline lbs::da::openservice::UserTrajStatus TrajStatusInfo::traj_status() const {
  return static_cast< lbs::da::openservice::UserTrajStatus >(traj_status_);
}
inline void TrajStatusInfo::set_traj_status(lbs::da::openservice::UserTrajStatus value) {
  GOOGLE_DCHECK(lbs::da::openservice::UserTrajStatus_IsValid(value));
  set_has_traj_status();
  traj_status_ = value;
}

// optional double mercator_x = 2;
inline bool TrajStatusInfo::has_mercator_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrajStatusInfo::set_has_mercator_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrajStatusInfo::clear_has_mercator_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrajStatusInfo::clear_mercator_x() {
  mercator_x_ = 0;
  clear_has_mercator_x();
}
inline double TrajStatusInfo::mercator_x() const {
  return mercator_x_;
}
inline void TrajStatusInfo::set_mercator_x(double value) {
  set_has_mercator_x();
  mercator_x_ = value;
}

// optional double mercator_y = 3;
inline bool TrajStatusInfo::has_mercator_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrajStatusInfo::set_has_mercator_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrajStatusInfo::clear_has_mercator_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrajStatusInfo::clear_mercator_y() {
  mercator_y_ = 0;
  clear_has_mercator_y();
}
inline double TrajStatusInfo::mercator_y() const {
  return mercator_y_;
}
inline void TrajStatusInfo::set_mercator_y(double value) {
  set_has_mercator_y();
  mercator_y_ = value;
}

// -------------------------------------------------------------------

// UserTriggeredInfo

// optional string cuid = 1;
inline bool UserTriggeredInfo::has_cuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTriggeredInfo::set_has_cuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTriggeredInfo::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTriggeredInfo::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& UserTriggeredInfo::cuid() const {
  return *cuid_;
}
inline void UserTriggeredInfo::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void UserTriggeredInfo::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void UserTriggeredInfo::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTriggeredInfo::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* UserTriggeredInfo::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string passport_id = 2;
inline bool UserTriggeredInfo::has_passport_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTriggeredInfo::set_has_passport_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTriggeredInfo::clear_has_passport_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTriggeredInfo::clear_passport_id() {
  if (passport_id_ != &::google::protobuf::internal::kEmptyString) {
    passport_id_->clear();
  }
  clear_has_passport_id();
}
inline const ::std::string& UserTriggeredInfo::passport_id() const {
  return *passport_id_;
}
inline void UserTriggeredInfo::set_passport_id(const ::std::string& value) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(value);
}
inline void UserTriggeredInfo::set_passport_id(const char* value) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(value);
}
inline void UserTriggeredInfo::set_passport_id(const char* value, size_t size) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTriggeredInfo::mutable_passport_id() {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  return passport_id_;
}
inline ::std::string* UserTriggeredInfo::release_passport_id() {
  clear_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passport_id_;
    passport_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double mercator_x = 3;
inline bool UserTriggeredInfo::has_mercator_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTriggeredInfo::set_has_mercator_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTriggeredInfo::clear_has_mercator_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTriggeredInfo::clear_mercator_x() {
  mercator_x_ = 0;
  clear_has_mercator_x();
}
inline double UserTriggeredInfo::mercator_x() const {
  return mercator_x_;
}
inline void UserTriggeredInfo::set_mercator_x(double value) {
  set_has_mercator_x();
  mercator_x_ = value;
}

// optional double mercator_y = 4;
inline bool UserTriggeredInfo::has_mercator_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTriggeredInfo::set_has_mercator_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTriggeredInfo::clear_has_mercator_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTriggeredInfo::clear_mercator_y() {
  mercator_y_ = 0;
  clear_has_mercator_y();
}
inline double UserTriggeredInfo::mercator_y() const {
  return mercator_y_;
}
inline void UserTriggeredInfo::set_mercator_y(double value) {
  set_has_mercator_y();
  mercator_y_ = value;
}

// optional string tsmcid = 5;
inline bool UserTriggeredInfo::has_tsmcid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTriggeredInfo::set_has_tsmcid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTriggeredInfo::clear_has_tsmcid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTriggeredInfo::clear_tsmcid() {
  if (tsmcid_ != &::google::protobuf::internal::kEmptyString) {
    tsmcid_->clear();
  }
  clear_has_tsmcid();
}
inline const ::std::string& UserTriggeredInfo::tsmcid() const {
  return *tsmcid_;
}
inline void UserTriggeredInfo::set_tsmcid(const ::std::string& value) {
  set_has_tsmcid();
  if (tsmcid_ == &::google::protobuf::internal::kEmptyString) {
    tsmcid_ = new ::std::string;
  }
  tsmcid_->assign(value);
}
inline void UserTriggeredInfo::set_tsmcid(const char* value) {
  set_has_tsmcid();
  if (tsmcid_ == &::google::protobuf::internal::kEmptyString) {
    tsmcid_ = new ::std::string;
  }
  tsmcid_->assign(value);
}
inline void UserTriggeredInfo::set_tsmcid(const char* value, size_t size) {
  set_has_tsmcid();
  if (tsmcid_ == &::google::protobuf::internal::kEmptyString) {
    tsmcid_ = new ::std::string;
  }
  tsmcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTriggeredInfo::mutable_tsmcid() {
  set_has_tsmcid();
  if (tsmcid_ == &::google::protobuf::internal::kEmptyString) {
    tsmcid_ = new ::std::string;
  }
  return tsmcid_;
}
inline ::std::string* UserTriggeredInfo::release_tsmcid() {
  clear_has_tsmcid();
  if (tsmcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tsmcid_;
    tsmcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 last_log_time = 6;
inline bool UserTriggeredInfo::has_last_log_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserTriggeredInfo::set_has_last_log_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserTriggeredInfo::clear_has_last_log_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserTriggeredInfo::clear_last_log_time() {
  last_log_time_ = GOOGLE_LONGLONG(0);
  clear_has_last_log_time();
}
inline ::google::protobuf::int64 UserTriggeredInfo::last_log_time() const {
  return last_log_time_;
}
inline void UserTriggeredInfo::set_last_log_time(::google::protobuf::int64 value) {
  set_has_last_log_time();
  last_log_time_ = value;
}

// optional int64 target_city = 7;
inline bool UserTriggeredInfo::has_target_city() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserTriggeredInfo::set_has_target_city() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserTriggeredInfo::clear_has_target_city() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserTriggeredInfo::clear_target_city() {
  target_city_ = GOOGLE_LONGLONG(0);
  clear_has_target_city();
}
inline ::google::protobuf::int64 UserTriggeredInfo::target_city() const {
  return target_city_;
}
inline void UserTriggeredInfo::set_target_city(::google::protobuf::int64 value) {
  set_has_target_city();
  target_city_ = value;
}

// optional string cond_id = 8;
inline bool UserTriggeredInfo::has_cond_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserTriggeredInfo::set_has_cond_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserTriggeredInfo::clear_has_cond_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserTriggeredInfo::clear_cond_id() {
  if (cond_id_ != &::google::protobuf::internal::kEmptyString) {
    cond_id_->clear();
  }
  clear_has_cond_id();
}
inline const ::std::string& UserTriggeredInfo::cond_id() const {
  return *cond_id_;
}
inline void UserTriggeredInfo::set_cond_id(const ::std::string& value) {
  set_has_cond_id();
  if (cond_id_ == &::google::protobuf::internal::kEmptyString) {
    cond_id_ = new ::std::string;
  }
  cond_id_->assign(value);
}
inline void UserTriggeredInfo::set_cond_id(const char* value) {
  set_has_cond_id();
  if (cond_id_ == &::google::protobuf::internal::kEmptyString) {
    cond_id_ = new ::std::string;
  }
  cond_id_->assign(value);
}
inline void UserTriggeredInfo::set_cond_id(const char* value, size_t size) {
  set_has_cond_id();
  if (cond_id_ == &::google::protobuf::internal::kEmptyString) {
    cond_id_ = new ::std::string;
  }
  cond_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTriggeredInfo::mutable_cond_id() {
  set_has_cond_id();
  if (cond_id_ == &::google::protobuf::internal::kEmptyString) {
    cond_id_ = new ::std::string;
  }
  return cond_id_;
}
inline ::std::string* UserTriggeredInfo::release_cond_id() {
  clear_has_cond_id();
  if (cond_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cond_id_;
    cond_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cond_tag = 9;
inline bool UserTriggeredInfo::has_cond_tag() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserTriggeredInfo::set_has_cond_tag() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserTriggeredInfo::clear_has_cond_tag() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserTriggeredInfo::clear_cond_tag() {
  if (cond_tag_ != &::google::protobuf::internal::kEmptyString) {
    cond_tag_->clear();
  }
  clear_has_cond_tag();
}
inline const ::std::string& UserTriggeredInfo::cond_tag() const {
  return *cond_tag_;
}
inline void UserTriggeredInfo::set_cond_tag(const ::std::string& value) {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  cond_tag_->assign(value);
}
inline void UserTriggeredInfo::set_cond_tag(const char* value) {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  cond_tag_->assign(value);
}
inline void UserTriggeredInfo::set_cond_tag(const char* value, size_t size) {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  cond_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTriggeredInfo::mutable_cond_tag() {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  return cond_tag_;
}
inline ::std::string* UserTriggeredInfo::release_cond_tag() {
  clear_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cond_tag_;
    cond_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string append = 10;
inline bool UserTriggeredInfo::has_append() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserTriggeredInfo::set_has_append() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserTriggeredInfo::clear_has_append() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserTriggeredInfo::clear_append() {
  if (append_ != &::google::protobuf::internal::kEmptyString) {
    append_->clear();
  }
  clear_has_append();
}
inline const ::std::string& UserTriggeredInfo::append() const {
  return *append_;
}
inline void UserTriggeredInfo::set_append(const ::std::string& value) {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  append_->assign(value);
}
inline void UserTriggeredInfo::set_append(const char* value) {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  append_->assign(value);
}
inline void UserTriggeredInfo::set_append(const char* value, size_t size) {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  append_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTriggeredInfo::mutable_append() {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  return append_;
}
inline ::std::string* UserTriggeredInfo::release_append() {
  clear_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = append_;
    append_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.PoiInfo triggered_poi = 11;
inline int UserTriggeredInfo::triggered_poi_size() const {
  return triggered_poi_.size();
}
inline void UserTriggeredInfo::clear_triggered_poi() {
  triggered_poi_.Clear();
}
inline const ::lbs::da::openservice::PoiInfo& UserTriggeredInfo::triggered_poi(int index) const {
  return triggered_poi_.Get(index);
}
inline ::lbs::da::openservice::PoiInfo* UserTriggeredInfo::mutable_triggered_poi(int index) {
  return triggered_poi_.Mutable(index);
}
inline ::lbs::da::openservice::PoiInfo* UserTriggeredInfo::add_triggered_poi() {
  return triggered_poi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >&
UserTriggeredInfo::triggered_poi() const {
  return triggered_poi_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >*
UserTriggeredInfo::mutable_triggered_poi() {
  return &triggered_poi_;
}

// repeated .lbs.da.openservice.AoiInfo triggered_aoi = 12;
inline int UserTriggeredInfo::triggered_aoi_size() const {
  return triggered_aoi_.size();
}
inline void UserTriggeredInfo::clear_triggered_aoi() {
  triggered_aoi_.Clear();
}
inline const ::lbs::da::openservice::AoiInfo& UserTriggeredInfo::triggered_aoi(int index) const {
  return triggered_aoi_.Get(index);
}
inline ::lbs::da::openservice::AoiInfo* UserTriggeredInfo::mutable_triggered_aoi(int index) {
  return triggered_aoi_.Mutable(index);
}
inline ::lbs::da::openservice::AoiInfo* UserTriggeredInfo::add_triggered_aoi() {
  return triggered_aoi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::AoiInfo >&
UserTriggeredInfo::triggered_aoi() const {
  return triggered_aoi_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::AoiInfo >*
UserTriggeredInfo::mutable_triggered_aoi() {
  return &triggered_aoi_;
}

// optional .lbs.da.openservice.TrajStatusInfo triggered_status = 13;
inline bool UserTriggeredInfo::has_triggered_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserTriggeredInfo::set_has_triggered_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserTriggeredInfo::clear_has_triggered_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserTriggeredInfo::clear_triggered_status() {
  if (triggered_status_ != NULL) triggered_status_->::lbs::da::openservice::TrajStatusInfo::Clear();
  clear_has_triggered_status();
}
inline const ::lbs::da::openservice::TrajStatusInfo& UserTriggeredInfo::triggered_status() const {
  return triggered_status_ != NULL ? *triggered_status_ : *default_instance_->triggered_status_;
}
inline ::lbs::da::openservice::TrajStatusInfo* UserTriggeredInfo::mutable_triggered_status() {
  set_has_triggered_status();
  if (triggered_status_ == NULL) triggered_status_ = new ::lbs::da::openservice::TrajStatusInfo;
  return triggered_status_;
}
inline ::lbs::da::openservice::TrajStatusInfo* UserTriggeredInfo::release_triggered_status() {
  clear_has_triggered_status();
  ::lbs::da::openservice::TrajStatusInfo* temp = triggered_status_;
  triggered_status_ = NULL;
  return temp;
}

// repeated .lbs.da.openservice.Rule triggered_rules = 14;
inline int UserTriggeredInfo::triggered_rules_size() const {
  return triggered_rules_.size();
}
inline void UserTriggeredInfo::clear_triggered_rules() {
  triggered_rules_.Clear();
}
inline const ::lbs::da::openservice::Rule& UserTriggeredInfo::triggered_rules(int index) const {
  return triggered_rules_.Get(index);
}
inline ::lbs::da::openservice::Rule* UserTriggeredInfo::mutable_triggered_rules(int index) {
  return triggered_rules_.Mutable(index);
}
inline ::lbs::da::openservice::Rule* UserTriggeredInfo::add_triggered_rules() {
  return triggered_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >&
UserTriggeredInfo::triggered_rules() const {
  return triggered_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >*
UserTriggeredInfo::mutable_triggered_rules() {
  return &triggered_rules_;
}

// optional string os_name = 15;
inline bool UserTriggeredInfo::has_os_name() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserTriggeredInfo::set_has_os_name() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserTriggeredInfo::clear_has_os_name() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserTriggeredInfo::clear_os_name() {
  if (os_name_ != &::google::protobuf::internal::kEmptyString) {
    os_name_->clear();
  }
  clear_has_os_name();
}
inline const ::std::string& UserTriggeredInfo::os_name() const {
  return *os_name_;
}
inline void UserTriggeredInfo::set_os_name(const ::std::string& value) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(value);
}
inline void UserTriggeredInfo::set_os_name(const char* value) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(value);
}
inline void UserTriggeredInfo::set_os_name(const char* value, size_t size) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTriggeredInfo::mutable_os_name() {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  return os_name_;
}
inline ::std::string* UserTriggeredInfo::release_os_name() {
  clear_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_name_;
    os_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetPushDetailRequest

// optional .lbs.da.openservice.RequestHeader header = 1;
inline bool GetPushDetailRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPushDetailRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPushDetailRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPushDetailRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetPushDetailRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetPushDetailRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetPushDetailRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// optional string cuid = 2;
inline bool GetPushDetailRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPushDetailRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPushDetailRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPushDetailRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& GetPushDetailRequest::cuid() const {
  return *cuid_;
}
inline void GetPushDetailRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetPushDetailRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetPushDetailRequest::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPushDetailRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* GetPushDetailRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string passport_id = 3;
inline bool GetPushDetailRequest::has_passport_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPushDetailRequest::set_has_passport_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPushDetailRequest::clear_has_passport_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPushDetailRequest::clear_passport_id() {
  if (passport_id_ != &::google::protobuf::internal::kEmptyString) {
    passport_id_->clear();
  }
  clear_has_passport_id();
}
inline const ::std::string& GetPushDetailRequest::passport_id() const {
  return *passport_id_;
}
inline void GetPushDetailRequest::set_passport_id(const ::std::string& value) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(value);
}
inline void GetPushDetailRequest::set_passport_id(const char* value) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(value);
}
inline void GetPushDetailRequest::set_passport_id(const char* value, size_t size) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPushDetailRequest::mutable_passport_id() {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  return passport_id_;
}
inline ::std::string* GetPushDetailRequest::release_passport_id() {
  clear_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passport_id_;
    passport_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cond_tag = 4;
inline bool GetPushDetailRequest::has_cond_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPushDetailRequest::set_has_cond_tag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPushDetailRequest::clear_has_cond_tag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPushDetailRequest::clear_cond_tag() {
  if (cond_tag_ != &::google::protobuf::internal::kEmptyString) {
    cond_tag_->clear();
  }
  clear_has_cond_tag();
}
inline const ::std::string& GetPushDetailRequest::cond_tag() const {
  return *cond_tag_;
}
inline void GetPushDetailRequest::set_cond_tag(const ::std::string& value) {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  cond_tag_->assign(value);
}
inline void GetPushDetailRequest::set_cond_tag(const char* value) {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  cond_tag_->assign(value);
}
inline void GetPushDetailRequest::set_cond_tag(const char* value, size_t size) {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  cond_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPushDetailRequest::mutable_cond_tag() {
  set_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    cond_tag_ = new ::std::string;
  }
  return cond_tag_;
}
inline ::std::string* GetPushDetailRequest::release_cond_tag() {
  clear_has_cond_tag();
  if (cond_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cond_tag_;
    cond_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .lbs.da.openservice.UserTriggeredInfo triggered_info = 5;
inline bool GetPushDetailRequest::has_triggered_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetPushDetailRequest::set_has_triggered_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetPushDetailRequest::clear_has_triggered_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetPushDetailRequest::clear_triggered_info() {
  if (triggered_info_ != NULL) triggered_info_->::lbs::da::openservice::UserTriggeredInfo::Clear();
  clear_has_triggered_info();
}
inline const ::lbs::da::openservice::UserTriggeredInfo& GetPushDetailRequest::triggered_info() const {
  return triggered_info_ != NULL ? *triggered_info_ : *default_instance_->triggered_info_;
}
inline ::lbs::da::openservice::UserTriggeredInfo* GetPushDetailRequest::mutable_triggered_info() {
  set_has_triggered_info();
  if (triggered_info_ == NULL) triggered_info_ = new ::lbs::da::openservice::UserTriggeredInfo;
  return triggered_info_;
}
inline ::lbs::da::openservice::UserTriggeredInfo* GetPushDetailRequest::release_triggered_info() {
  clear_has_triggered_info();
  ::lbs::da::openservice::UserTriggeredInfo* temp = triggered_info_;
  triggered_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RedisKeyVal

// optional string source = 1;
inline bool RedisKeyVal::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedisKeyVal::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedisKeyVal::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedisKeyVal::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& RedisKeyVal::source() const {
  return *source_;
}
inline void RedisKeyVal::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void RedisKeyVal::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void RedisKeyVal::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedisKeyVal::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* RedisKeyVal::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string key = 2;
inline bool RedisKeyVal::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedisKeyVal::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedisKeyVal::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedisKeyVal::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RedisKeyVal::key() const {
  return *key_;
}
inline void RedisKeyVal::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RedisKeyVal::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RedisKeyVal::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedisKeyVal::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RedisKeyVal::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string val = 3;
inline bool RedisKeyVal::has_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedisKeyVal::set_has_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedisKeyVal::clear_has_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedisKeyVal::clear_val() {
  if (val_ != &::google::protobuf::internal::kEmptyString) {
    val_->clear();
  }
  clear_has_val();
}
inline const ::std::string& RedisKeyVal::val() const {
  return *val_;
}
inline void RedisKeyVal::set_val(const ::std::string& value) {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline void RedisKeyVal::set_val(const char* value) {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline void RedisKeyVal::set_val(const char* value, size_t size) {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedisKeyVal::mutable_val() {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  return val_;
}
inline ::std::string* RedisKeyVal::release_val() {
  clear_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = val_;
    val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 expire_seconds = 4;
inline bool RedisKeyVal::has_expire_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedisKeyVal::set_has_expire_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedisKeyVal::clear_has_expire_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedisKeyVal::clear_expire_seconds() {
  expire_seconds_ = GOOGLE_LONGLONG(0);
  clear_has_expire_seconds();
}
inline ::google::protobuf::int64 RedisKeyVal::expire_seconds() const {
  return expire_seconds_;
}
inline void RedisKeyVal::set_expire_seconds(::google::protobuf::int64 value) {
  set_has_expire_seconds();
  expire_seconds_ = value;
}

// -------------------------------------------------------------------

// MsgCenterPushInfo

// optional int32 tuanid = 1;
inline bool MsgCenterPushInfo::has_tuanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgCenterPushInfo::set_has_tuanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgCenterPushInfo::clear_has_tuanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgCenterPushInfo::clear_tuanid() {
  tuanid_ = 0;
  clear_has_tuanid();
}
inline ::google::protobuf::int32 MsgCenterPushInfo::tuanid() const {
  return tuanid_;
}
inline void MsgCenterPushInfo::set_tuanid(::google::protobuf::int32 value) {
  set_has_tuanid();
  tuanid_ = value;
}

// optional int32 situationid = 2;
inline bool MsgCenterPushInfo::has_situationid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgCenterPushInfo::set_has_situationid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgCenterPushInfo::clear_has_situationid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgCenterPushInfo::clear_situationid() {
  situationid_ = 0;
  clear_has_situationid();
}
inline ::google::protobuf::int32 MsgCenterPushInfo::situationid() const {
  return situationid_;
}
inline void MsgCenterPushInfo::set_situationid(::google::protobuf::int32 value) {
  set_has_situationid();
  situationid_ = value;
}

// optional int32 startday = 3;
inline bool MsgCenterPushInfo::has_startday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgCenterPushInfo::set_has_startday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgCenterPushInfo::clear_has_startday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgCenterPushInfo::clear_startday() {
  startday_ = 0;
  clear_has_startday();
}
inline ::google::protobuf::int32 MsgCenterPushInfo::startday() const {
  return startday_;
}
inline void MsgCenterPushInfo::set_startday(::google::protobuf::int32 value) {
  set_has_startday();
  startday_ = value;
}

// optional int32 daysize = 4;
inline bool MsgCenterPushInfo::has_daysize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgCenterPushInfo::set_has_daysize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgCenterPushInfo::clear_has_daysize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgCenterPushInfo::clear_daysize() {
  daysize_ = 0;
  clear_has_daysize();
}
inline ::google::protobuf::int32 MsgCenterPushInfo::daysize() const {
  return daysize_;
}
inline void MsgCenterPushInfo::set_daysize(::google::protobuf::int32 value) {
  set_has_daysize();
  daysize_ = value;
}

// optional int32 dealsize = 5;
inline bool MsgCenterPushInfo::has_dealsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgCenterPushInfo::set_has_dealsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgCenterPushInfo::clear_has_dealsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgCenterPushInfo::clear_dealsize() {
  dealsize_ = 0;
  clear_has_dealsize();
}
inline ::google::protobuf::int32 MsgCenterPushInfo::dealsize() const {
  return dealsize_;
}
inline void MsgCenterPushInfo::set_dealsize(::google::protobuf::int32 value) {
  set_has_dealsize();
  dealsize_ = value;
}

// optional int32 strsitelist = 6;
inline bool MsgCenterPushInfo::has_strsitelist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgCenterPushInfo::set_has_strsitelist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgCenterPushInfo::clear_has_strsitelist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgCenterPushInfo::clear_strsitelist() {
  strsitelist_ = 0;
  clear_has_strsitelist();
}
inline ::google::protobuf::int32 MsgCenterPushInfo::strsitelist() const {
  return strsitelist_;
}
inline void MsgCenterPushInfo::set_strsitelist(::google::protobuf::int32 value) {
  set_has_strsitelist();
  strsitelist_ = value;
}

// optional int32 eventid = 7;
inline bool MsgCenterPushInfo::has_eventid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgCenterPushInfo::set_has_eventid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgCenterPushInfo::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgCenterPushInfo::clear_eventid() {
  eventid_ = 0;
  clear_has_eventid();
}
inline ::google::protobuf::int32 MsgCenterPushInfo::eventid() const {
  return eventid_;
}
inline void MsgCenterPushInfo::set_eventid(::google::protobuf::int32 value) {
  set_has_eventid();
  eventid_ = value;
}

// -------------------------------------------------------------------

// MsgCenterPushDetail

// optional string pid = 1;
inline bool MsgCenterPushDetail::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgCenterPushDetail::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgCenterPushDetail::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgCenterPushDetail::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& MsgCenterPushDetail::pid() const {
  return *pid_;
}
inline void MsgCenterPushDetail::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void MsgCenterPushDetail::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void MsgCenterPushDetail::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgCenterPushDetail::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* MsgCenterPushDetail::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 utype = 2;
inline bool MsgCenterPushDetail::has_utype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgCenterPushDetail::set_has_utype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgCenterPushDetail::clear_has_utype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgCenterPushDetail::clear_utype() {
  utype_ = 0;
  clear_has_utype();
}
inline ::google::protobuf::int32 MsgCenterPushDetail::utype() const {
  return utype_;
}
inline void MsgCenterPushDetail::set_utype(::google::protobuf::int32 value) {
  set_has_utype();
  utype_ = value;
}

// optional string uid = 3;
inline bool MsgCenterPushDetail::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgCenterPushDetail::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgCenterPushDetail::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgCenterPushDetail::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& MsgCenterPushDetail::uid() const {
  return *uid_;
}
inline void MsgCenterPushDetail::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void MsgCenterPushDetail::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void MsgCenterPushDetail::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgCenterPushDetail::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* MsgCenterPushDetail::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string title = 4;
inline bool MsgCenterPushDetail::has_title() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgCenterPushDetail::set_has_title() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgCenterPushDetail::clear_has_title() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgCenterPushDetail::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& MsgCenterPushDetail::title() const {
  return *title_;
}
inline void MsgCenterPushDetail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MsgCenterPushDetail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MsgCenterPushDetail::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgCenterPushDetail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* MsgCenterPushDetail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string content = 5;
inline bool MsgCenterPushDetail::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgCenterPushDetail::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgCenterPushDetail::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgCenterPushDetail::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& MsgCenterPushDetail::content() const {
  return *content_;
}
inline void MsgCenterPushDetail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MsgCenterPushDetail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MsgCenterPushDetail::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgCenterPushDetail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* MsgCenterPushDetail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 type = 6;
inline bool MsgCenterPushDetail::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgCenterPushDetail::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgCenterPushDetail::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgCenterPushDetail::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MsgCenterPushDetail::type() const {
  return type_;
}
inline void MsgCenterPushDetail::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 prod = 7 [default = 1];
inline bool MsgCenterPushDetail::has_prod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgCenterPushDetail::set_has_prod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgCenterPushDetail::clear_has_prod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgCenterPushDetail::clear_prod() {
  prod_ = 1;
  clear_has_prod();
}
inline ::google::protobuf::int32 MsgCenterPushDetail::prod() const {
  return prod_;
}
inline void MsgCenterPushDetail::set_prod(::google::protobuf::int32 value) {
  set_has_prod();
  prod_ = value;
}

// optional string operator = 8;
inline bool MsgCenterPushDetail::has_operator_() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgCenterPushDetail::set_has_operator_() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgCenterPushDetail::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgCenterPushDetail::clear_operator_() {
  if (operator__ != &::google::protobuf::internal::kEmptyString) {
    operator__->clear();
  }
  clear_has_operator_();
}
inline const ::std::string& MsgCenterPushDetail::operator_() const {
  return *operator__;
}
inline void MsgCenterPushDetail::set_operator_(const ::std::string& value) {
  set_has_operator_();
  if (operator__ == &::google::protobuf::internal::kEmptyString) {
    operator__ = new ::std::string;
  }
  operator__->assign(value);
}
inline void MsgCenterPushDetail::set_operator_(const char* value) {
  set_has_operator_();
  if (operator__ == &::google::protobuf::internal::kEmptyString) {
    operator__ = new ::std::string;
  }
  operator__->assign(value);
}
inline void MsgCenterPushDetail::set_operator_(const char* value, size_t size) {
  set_has_operator_();
  if (operator__ == &::google::protobuf::internal::kEmptyString) {
    operator__ = new ::std::string;
  }
  operator__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgCenterPushDetail::mutable_operator_() {
  set_has_operator_();
  if (operator__ == &::google::protobuf::internal::kEmptyString) {
    operator__ = new ::std::string;
  }
  return operator__;
}
inline ::std::string* MsgCenterPushDetail::release_operator_() {
  clear_has_operator_();
  if (operator__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator__;
    operator__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string src = 9 [default = "srh"];
inline bool MsgCenterPushDetail::has_src() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgCenterPushDetail::set_has_src() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgCenterPushDetail::clear_has_src() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgCenterPushDetail::clear_src() {
  if (src_ != &_default_src_) {
    src_->assign(_default_src_);
  }
  clear_has_src();
}
inline const ::std::string& MsgCenterPushDetail::src() const {
  return *src_;
}
inline void MsgCenterPushDetail::set_src(const ::std::string& value) {
  set_has_src();
  if (src_ == &_default_src_) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgCenterPushDetail::set_src(const char* value) {
  set_has_src();
  if (src_ == &_default_src_) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgCenterPushDetail::set_src(const char* value, size_t size) {
  set_has_src();
  if (src_ == &_default_src_) {
    src_ = new ::std::string;
  }
  src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgCenterPushDetail::mutable_src() {
  set_has_src();
  if (src_ == &_default_src_) {
    src_ = new ::std::string(_default_src_);
  }
  return src_;
}
inline ::std::string* MsgCenterPushDetail::release_src() {
  clear_has_src();
  if (src_ == &_default_src_) {
    return NULL;
  } else {
    ::std::string* temp = src_;
    src_ = const_cast< ::std::string*>(&_default_src_);
    return temp;
  }
}

// optional int32 at = 10 [default = 0];
inline bool MsgCenterPushDetail::has_at() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgCenterPushDetail::set_has_at() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgCenterPushDetail::clear_has_at() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgCenterPushDetail::clear_at() {
  at_ = 0;
  clear_has_at();
}
inline ::google::protobuf::int32 MsgCenterPushDetail::at() const {
  return at_;
}
inline void MsgCenterPushDetail::set_at(::google::protobuf::int32 value) {
  set_has_at();
  at_ = value;
}

// optional int32 seq = 11 [default = -1];
inline bool MsgCenterPushDetail::has_seq() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgCenterPushDetail::set_has_seq() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgCenterPushDetail::clear_has_seq() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgCenterPushDetail::clear_seq() {
  seq_ = -1;
  clear_has_seq();
}
inline ::google::protobuf::int32 MsgCenterPushDetail::seq() const {
  return seq_;
}
inline void MsgCenterPushDetail::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// optional int32 et = 12 [default = 0];
inline bool MsgCenterPushDetail::has_et() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgCenterPushDetail::set_has_et() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgCenterPushDetail::clear_has_et() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgCenterPushDetail::clear_et() {
  et_ = 0;
  clear_has_et();
}
inline ::google::protobuf::int32 MsgCenterPushDetail::et() const {
  return et_;
}
inline void MsgCenterPushDetail::set_et(::google::protobuf::int32 value) {
  set_has_et();
  et_ = value;
}

// optional int32 exp = 13;
inline bool MsgCenterPushDetail::has_exp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MsgCenterPushDetail::set_has_exp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MsgCenterPushDetail::clear_has_exp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MsgCenterPushDetail::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 MsgCenterPushDetail::exp() const {
  return exp_;
}
inline void MsgCenterPushDetail::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional .lbs.da.openservice.MsgCenterPushInfo info = 14;
inline bool MsgCenterPushDetail::has_info() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MsgCenterPushDetail::set_has_info() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MsgCenterPushDetail::clear_has_info() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MsgCenterPushDetail::clear_info() {
  if (info_ != NULL) info_->::lbs::da::openservice::MsgCenterPushInfo::Clear();
  clear_has_info();
}
inline const ::lbs::da::openservice::MsgCenterPushInfo& MsgCenterPushDetail::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::lbs::da::openservice::MsgCenterPushInfo* MsgCenterPushDetail::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::lbs::da::openservice::MsgCenterPushInfo;
  return info_;
}
inline ::lbs::da::openservice::MsgCenterPushInfo* MsgCenterPushDetail::release_info() {
  clear_has_info();
  ::lbs::da::openservice::MsgCenterPushInfo* temp = info_;
  info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetPushDetailResponse

// optional string trigger_cond_id = 1;
inline bool GetPushDetailResponse::has_trigger_cond_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPushDetailResponse::set_has_trigger_cond_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPushDetailResponse::clear_has_trigger_cond_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPushDetailResponse::clear_trigger_cond_id() {
  if (trigger_cond_id_ != &::google::protobuf::internal::kEmptyString) {
    trigger_cond_id_->clear();
  }
  clear_has_trigger_cond_id();
}
inline const ::std::string& GetPushDetailResponse::trigger_cond_id() const {
  return *trigger_cond_id_;
}
inline void GetPushDetailResponse::set_trigger_cond_id(const ::std::string& value) {
  set_has_trigger_cond_id();
  if (trigger_cond_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_cond_id_ = new ::std::string;
  }
  trigger_cond_id_->assign(value);
}
inline void GetPushDetailResponse::set_trigger_cond_id(const char* value) {
  set_has_trigger_cond_id();
  if (trigger_cond_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_cond_id_ = new ::std::string;
  }
  trigger_cond_id_->assign(value);
}
inline void GetPushDetailResponse::set_trigger_cond_id(const char* value, size_t size) {
  set_has_trigger_cond_id();
  if (trigger_cond_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_cond_id_ = new ::std::string;
  }
  trigger_cond_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPushDetailResponse::mutable_trigger_cond_id() {
  set_has_trigger_cond_id();
  if (trigger_cond_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_cond_id_ = new ::std::string;
  }
  return trigger_cond_id_;
}
inline ::std::string* GetPushDetailResponse::release_trigger_cond_id() {
  clear_has_trigger_cond_id();
  if (trigger_cond_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_cond_id_;
    trigger_cond_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cuid = 2;
inline bool GetPushDetailResponse::has_cuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPushDetailResponse::set_has_cuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPushDetailResponse::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPushDetailResponse::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& GetPushDetailResponse::cuid() const {
  return *cuid_;
}
inline void GetPushDetailResponse::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetPushDetailResponse::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetPushDetailResponse::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPushDetailResponse::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* GetPushDetailResponse::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string passport_id = 3;
inline bool GetPushDetailResponse::has_passport_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPushDetailResponse::set_has_passport_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPushDetailResponse::clear_has_passport_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPushDetailResponse::clear_passport_id() {
  if (passport_id_ != &::google::protobuf::internal::kEmptyString) {
    passport_id_->clear();
  }
  clear_has_passport_id();
}
inline const ::std::string& GetPushDetailResponse::passport_id() const {
  return *passport_id_;
}
inline void GetPushDetailResponse::set_passport_id(const ::std::string& value) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(value);
}
inline void GetPushDetailResponse::set_passport_id(const char* value) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(value);
}
inline void GetPushDetailResponse::set_passport_id(const char* value, size_t size) {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  passport_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPushDetailResponse::mutable_passport_id() {
  set_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    passport_id_ = new ::std::string;
  }
  return passport_id_;
}
inline ::std::string* GetPushDetailResponse::release_passport_id() {
  clear_has_passport_id();
  if (passport_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passport_id_;
    passport_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.RedisKeyVal redis_data = 5;
inline int GetPushDetailResponse::redis_data_size() const {
  return redis_data_.size();
}
inline void GetPushDetailResponse::clear_redis_data() {
  redis_data_.Clear();
}
inline const ::lbs::da::openservice::RedisKeyVal& GetPushDetailResponse::redis_data(int index) const {
  return redis_data_.Get(index);
}
inline ::lbs::da::openservice::RedisKeyVal* GetPushDetailResponse::mutable_redis_data(int index) {
  return redis_data_.Mutable(index);
}
inline ::lbs::da::openservice::RedisKeyVal* GetPushDetailResponse::add_redis_data() {
  return redis_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RedisKeyVal >&
GetPushDetailResponse::redis_data() const {
  return redis_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RedisKeyVal >*
GetPushDetailResponse::mutable_redis_data() {
  return &redis_data_;
}

// optional .lbs.da.openservice.MsgCenterPushDetail push_detail = 6;
inline bool GetPushDetailResponse::has_push_detail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetPushDetailResponse::set_has_push_detail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetPushDetailResponse::clear_has_push_detail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetPushDetailResponse::clear_push_detail() {
  if (push_detail_ != NULL) push_detail_->::lbs::da::openservice::MsgCenterPushDetail::Clear();
  clear_has_push_detail();
}
inline const ::lbs::da::openservice::MsgCenterPushDetail& GetPushDetailResponse::push_detail() const {
  return push_detail_ != NULL ? *push_detail_ : *default_instance_->push_detail_;
}
inline ::lbs::da::openservice::MsgCenterPushDetail* GetPushDetailResponse::mutable_push_detail() {
  set_has_push_detail();
  if (push_detail_ == NULL) push_detail_ = new ::lbs::da::openservice::MsgCenterPushDetail;
  return push_detail_;
}
inline ::lbs::da::openservice::MsgCenterPushDetail* GetPushDetailResponse::release_push_detail() {
  clear_has_push_detail();
  ::lbs::da::openservice::MsgCenterPushDetail* temp = push_detail_;
  push_detail_ = NULL;
  return temp;
}

// optional string sample_ids = 7;
inline bool GetPushDetailResponse::has_sample_ids() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetPushDetailResponse::set_has_sample_ids() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetPushDetailResponse::clear_has_sample_ids() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetPushDetailResponse::clear_sample_ids() {
  if (sample_ids_ != &::google::protobuf::internal::kEmptyString) {
    sample_ids_->clear();
  }
  clear_has_sample_ids();
}
inline const ::std::string& GetPushDetailResponse::sample_ids() const {
  return *sample_ids_;
}
inline void GetPushDetailResponse::set_sample_ids(const ::std::string& value) {
  set_has_sample_ids();
  if (sample_ids_ == &::google::protobuf::internal::kEmptyString) {
    sample_ids_ = new ::std::string;
  }
  sample_ids_->assign(value);
}
inline void GetPushDetailResponse::set_sample_ids(const char* value) {
  set_has_sample_ids();
  if (sample_ids_ == &::google::protobuf::internal::kEmptyString) {
    sample_ids_ = new ::std::string;
  }
  sample_ids_->assign(value);
}
inline void GetPushDetailResponse::set_sample_ids(const char* value, size_t size) {
  set_has_sample_ids();
  if (sample_ids_ == &::google::protobuf::internal::kEmptyString) {
    sample_ids_ = new ::std::string;
  }
  sample_ids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPushDetailResponse::mutable_sample_ids() {
  set_has_sample_ids();
  if (sample_ids_ == &::google::protobuf::internal::kEmptyString) {
    sample_ids_ = new ::std::string;
  }
  return sample_ids_;
}
inline ::std::string* GetPushDetailResponse::release_sample_ids() {
  clear_has_sample_ids();
  if (sample_ids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sample_ids_;
    sample_ids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .lbs.da.openservice.PushActionType action_type = 8;
inline bool GetPushDetailResponse::has_action_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetPushDetailResponse::set_has_action_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetPushDetailResponse::clear_has_action_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetPushDetailResponse::clear_action_type() {
  action_type_ = 1;
  clear_has_action_type();
}
inline lbs::da::openservice::PushActionType GetPushDetailResponse::action_type() const {
  return static_cast< lbs::da::openservice::PushActionType >(action_type_);
}
inline void GetPushDetailResponse::set_action_type(lbs::da::openservice::PushActionType value) {
  GOOGLE_DCHECK(lbs::da::openservice::PushActionType_IsValid(value));
  set_has_action_type();
  action_type_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace openservice
}  // namespace da
}  // namespace lbs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::PushActionType>() {
  return lbs::da::openservice::PushActionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_realtime_5fpush_2eproto__INCLUDED
