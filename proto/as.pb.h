// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: as.proto

#ifndef PROTOBUF_as_2eproto__INCLUDED
#define PROTOBUF_as_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace lbs {
namespace da {
namespace openservice {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_as_2eproto();
void protobuf_AssignDesc_as_2eproto();
void protobuf_ShutdownFile_as_2eproto();

class ASRequest;
class ASFacetDetail;
class ASPoiDetail;
class ASDistInfo;
class ASDealDetail;
class ASResponse;

// ===================================================================

class ASRequest : public ::google::protobuf::Message {
 public:
  ASRequest();
  virtual ~ASRequest();
  
  ASRequest(const ASRequest& from);
  
  inline ASRequest& operator=(const ASRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ASRequest& default_instance();
  
  void Swap(ASRequest* other);
  
  // implements Message ----------------------------------------------
  
  ASRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASRequest& from);
  void MergeFrom(const ASRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 is_new = 1 [default = 0];
  inline bool has_is_new() const;
  inline void clear_is_new();
  static const int kIsNewFieldNumber = 1;
  inline ::google::protobuf::int32 is_new() const;
  inline void set_is_new(::google::protobuf::int32 value);
  
  // optional int32 checkin_time = 2 [default = -1];
  inline bool has_checkin_time() const;
  inline void clear_checkin_time();
  static const int kCheckinTimeFieldNumber = 2;
  inline ::google::protobuf::int32 checkin_time() const;
  inline void set_checkin_time(::google::protobuf::int32 value);
  
  // optional int32 checkout_time = 3 [default = -1];
  inline bool has_checkout_time() const;
  inline void clear_checkout_time();
  static const int kCheckoutTimeFieldNumber = 3;
  inline ::google::protobuf::int32 checkout_time() const;
  inline void set_checkout_time(::google::protobuf::int32 value);
  
  // optional int64 city_id = 4;
  inline bool has_city_id() const;
  inline void clear_city_id();
  static const int kCityIdFieldNumber = 4;
  inline ::google::protobuf::int64 city_id() const;
  inline void set_city_id(::google::protobuf::int64 value);
  
  // optional int32 channel_type = 5 [default = 8];
  inline bool has_channel_type() const;
  inline void clear_channel_type();
  static const int kChannelTypeFieldNumber = 5;
  inline ::google::protobuf::int32 channel_type() const;
  inline void set_channel_type(::google::protobuf::int32 value);
  
  // optional string str_catg = 6 [default = "0"];
  inline bool has_str_catg() const;
  inline void clear_str_catg();
  static const int kStrCatgFieldNumber = 6;
  inline const ::std::string& str_catg() const;
  inline void set_str_catg(const ::std::string& value);
  inline void set_str_catg(const char* value);
  inline void set_str_catg(const char* value, size_t size);
  inline ::std::string* mutable_str_catg();
  inline ::std::string* release_str_catg();
  
  // optional string str_subcatg = 7 [default = "0"];
  inline bool has_str_subcatg() const;
  inline void clear_str_subcatg();
  static const int kStrSubcatgFieldNumber = 7;
  inline const ::std::string& str_subcatg() const;
  inline void set_str_subcatg(const ::std::string& value);
  inline void set_str_subcatg(const char* value);
  inline void set_str_subcatg(const char* value, size_t size);
  inline ::std::string* mutable_str_subcatg();
  inline ::std::string* release_str_subcatg();
  
  // optional string str_thdcatg = 8 [default = "0"];
  inline bool has_str_thdcatg() const;
  inline void clear_str_thdcatg();
  static const int kStrThdcatgFieldNumber = 8;
  inline const ::std::string& str_thdcatg() const;
  inline void set_str_thdcatg(const ::std::string& value);
  inline void set_str_thdcatg(const char* value);
  inline void set_str_thdcatg(const char* value, size_t size);
  inline ::std::string* mutable_str_thdcatg();
  inline ::std::string* release_str_thdcatg();
  
  // optional string str_shop_dist = 9 [default = "0"];
  inline bool has_str_shop_dist() const;
  inline void clear_str_shop_dist();
  static const int kStrShopDistFieldNumber = 9;
  inline const ::std::string& str_shop_dist() const;
  inline void set_str_shop_dist(const ::std::string& value);
  inline void set_str_shop_dist(const char* value);
  inline void set_str_shop_dist(const char* value, size_t size);
  inline ::std::string* mutable_str_shop_dist();
  inline ::std::string* release_str_shop_dist();
  
  // optional string str_shop_range = 10 [default = "0"];
  inline bool has_str_shop_range() const;
  inline void clear_str_shop_range();
  static const int kStrShopRangeFieldNumber = 10;
  inline const ::std::string& str_shop_range() const;
  inline void set_str_shop_range(const ::std::string& value);
  inline void set_str_shop_range(const char* value);
  inline void set_str_shop_range(const char* value, size_t size);
  inline ::std::string* mutable_str_shop_range();
  inline ::std::string* release_str_shop_range();
  
  // optional string str_sub_line = 11;
  inline bool has_str_sub_line() const;
  inline void clear_str_sub_line();
  static const int kStrSubLineFieldNumber = 11;
  inline const ::std::string& str_sub_line() const;
  inline void set_str_sub_line(const ::std::string& value);
  inline void set_str_sub_line(const char* value);
  inline void set_str_sub_line(const char* value, size_t size);
  inline ::std::string* mutable_str_sub_line();
  inline ::std::string* release_str_sub_line();
  
  // optional string str_sub_station = 12;
  inline bool has_str_sub_station() const;
  inline void clear_str_sub_station();
  static const int kStrSubStationFieldNumber = 12;
  inline const ::std::string& str_sub_station() const;
  inline void set_str_sub_station(const ::std::string& value);
  inline void set_str_sub_station(const char* value);
  inline void set_str_sub_station(const char* value, size_t size);
  inline ::std::string* mutable_str_sub_station();
  inline ::std::string* release_str_sub_station();
  
  // repeated int32 sub_station = 13;
  inline int sub_station_size() const;
  inline void clear_sub_station();
  static const int kSubStationFieldNumber = 13;
  inline ::google::protobuf::int32 sub_station(int index) const;
  inline void set_sub_station(int index, ::google::protobuf::int32 value);
  inline void add_sub_station(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sub_station() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sub_station();
  
  // optional string str_site_list = 14 [default = "0"];
  inline bool has_str_site_list() const;
  inline void clear_str_site_list();
  static const int kStrSiteListFieldNumber = 14;
  inline const ::std::string& str_site_list() const;
  inline void set_str_site_list(const ::std::string& value);
  inline void set_str_site_list(const char* value);
  inline void set_str_site_list(const char* value, size_t size);
  inline ::std::string* mutable_str_site_list();
  inline ::std::string* release_str_site_list();
  
  // optional int32 sort_type = 15 [default = 0];
  inline bool has_sort_type() const;
  inline void clear_sort_type();
  static const int kSortTypeFieldNumber = 15;
  inline ::google::protobuf::int32 sort_type() const;
  inline void set_sort_type(::google::protobuf::int32 value);
  
  // optional int32 start_idx = 16 [default = 1];
  inline bool has_start_idx() const;
  inline void clear_start_idx();
  static const int kStartIdxFieldNumber = 16;
  inline ::google::protobuf::int32 start_idx() const;
  inline void set_start_idx(::google::protobuf::int32 value);
  
  // optional int32 goods_per_page = 17 [default = 91];
  inline bool has_goods_per_page() const;
  inline void clear_goods_per_page();
  static const int kGoodsPerPageFieldNumber = 17;
  inline ::google::protobuf::int32 goods_per_page() const;
  inline void set_goods_per_page(::google::protobuf::int32 value);
  
  // optional int32 good_num = 18 [default = 91];
  inline bool has_good_num() const;
  inline void clear_good_num();
  static const int kGoodNumFieldNumber = 18;
  inline ::google::protobuf::int32 good_num() const;
  inline void set_good_num(::google::protobuf::int32 value);
  
  // optional int32 poi_per_page = 19 [default = 10];
  inline bool has_poi_per_page() const;
  inline void clear_poi_per_page();
  static const int kPoiPerPageFieldNumber = 19;
  inline ::google::protobuf::int32 poi_per_page() const;
  inline void set_poi_per_page(::google::protobuf::int32 value);
  
  // optional int32 poi_num = 20 [default = 20];
  inline bool has_poi_num() const;
  inline void clear_poi_num();
  static const int kPoiNumFieldNumber = 20;
  inline ::google::protobuf::int32 poi_num() const;
  inline void set_poi_num(::google::protobuf::int32 value);
  
  // optional int32 goods_per_poi = 21 [default = 10];
  inline bool has_goods_per_poi() const;
  inline void clear_goods_per_poi();
  static const int kGoodsPerPoiFieldNumber = 21;
  inline ::google::protobuf::int32 goods_per_poi() const;
  inline void set_goods_per_poi(::google::protobuf::int32 value);
  
  // optional string cuid = 22 [default = ""];
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 22;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional int32 client = 23 [default = 3];
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 23;
  inline ::google::protobuf::int32 client() const;
  inline void set_client(::google::protobuf::int32 value);
  
  // optional string s = 24 [default = "realtime_push"];
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 24;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  
  // optional string baidu_id = 25;
  inline bool has_baidu_id() const;
  inline void clear_baidu_id();
  static const int kBaiduIdFieldNumber = 25;
  inline const ::std::string& baidu_id() const;
  inline void set_baidu_id(const ::std::string& value);
  inline void set_baidu_id(const char* value);
  inline void set_baidu_id(const char* value, size_t size);
  inline ::std::string* mutable_baidu_id();
  inline ::std::string* release_baidu_id();
  
  // optional int32 is_expired = 26 [default = 0];
  inline bool has_is_expired() const;
  inline void clear_is_expired();
  static const int kIsExpiredFieldNumber = 26;
  inline ::google::protobuf::int32 is_expired() const;
  inline void set_is_expired(::google::protobuf::int32 value);
  
  // optional string location = 27;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 27;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  
  // optional string keywords = 29;
  inline bool has_keywords() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 29;
  inline const ::std::string& keywords() const;
  inline void set_keywords(const ::std::string& value);
  inline void set_keywords(const char* value);
  inline void set_keywords(const char* value, size_t size);
  inline ::std::string* mutable_keywords();
  inline ::std::string* release_keywords();
  
  // optional int32 is_goflush = 30 [default = 0];
  inline bool has_is_goflush() const;
  inline void clear_is_goflush();
  static const int kIsGoflushFieldNumber = 30;
  inline ::google::protobuf::int32 is_goflush() const;
  inline void set_is_goflush(::google::protobuf::int32 value);
  
  // optional string tags = 31;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 31;
  inline const ::std::string& tags() const;
  inline void set_tags(const ::std::string& value);
  inline void set_tags(const char* value);
  inline void set_tags(const char* value, size_t size);
  inline ::std::string* mutable_tags();
  inline ::std::string* release_tags();
  
  // optional string border = 32;
  inline bool has_border() const;
  inline void clear_border();
  static const int kBorderFieldNumber = 32;
  inline const ::std::string& border() const;
  inline void set_border(const ::std::string& value);
  inline void set_border(const char* value);
  inline void set_border(const char* value, size_t size);
  inline ::std::string* mutable_border();
  inline ::std::string* release_border();
  
  // optional int32 border_start_distance = 33;
  inline bool has_border_start_distance() const;
  inline void clear_border_start_distance();
  static const int kBorderStartDistanceFieldNumber = 33;
  inline ::google::protobuf::int32 border_start_distance() const;
  inline void set_border_start_distance(::google::protobuf::int32 value);
  
  // optional int32 border_distance = 34 [default = 500];
  inline bool has_border_distance() const;
  inline void clear_border_distance();
  static const int kBorderDistanceFieldNumber = 34;
  inline ::google::protobuf::int32 border_distance() const;
  inline void set_border_distance(::google::protobuf::int32 value);
  
  // optional int32 verbose = 35;
  inline bool has_verbose() const;
  inline void clear_verbose();
  static const int kVerboseFieldNumber = 35;
  inline ::google::protobuf::int32 verbose() const;
  inline void set_verbose(::google::protobuf::int32 value);
  
  // optional string coor_sys = 36 [default = "google"];
  inline bool has_coor_sys() const;
  inline void clear_coor_sys();
  static const int kCoorSysFieldNumber = 36;
  inline const ::std::string& coor_sys() const;
  inline void set_coor_sys(const ::std::string& value);
  inline void set_coor_sys(const char* value);
  inline void set_coor_sys(const char* value, size_t size);
  inline ::std::string* mutable_coor_sys();
  inline ::std::string* release_coor_sys();
  
  // optional string nearby_id = 37;
  inline bool has_nearby_id() const;
  inline void clear_nearby_id();
  static const int kNearbyIdFieldNumber = 37;
  inline const ::std::string& nearby_id() const;
  inline void set_nearby_id(const ::std::string& value);
  inline void set_nearby_id(const char* value);
  inline void set_nearby_id(const char* value, size_t size);
  inline ::std::string* mutable_nearby_id();
  inline ::std::string* release_nearby_id();
  
  // optional string str_customized_location = 38;
  inline bool has_str_customized_location() const;
  inline void clear_str_customized_location();
  static const int kStrCustomizedLocationFieldNumber = 38;
  inline const ::std::string& str_customized_location() const;
  inline void set_str_customized_location(const ::std::string& value);
  inline void set_str_customized_location(const char* value);
  inline void set_str_customized_location(const char* value, size_t size);
  inline ::std::string* mutable_str_customized_location();
  inline ::std::string* release_str_customized_location();
  
  // optional string userID = 39;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 39;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional string need_poi = 40 [default = "1"];
  inline bool has_need_poi() const;
  inline void clear_need_poi();
  static const int kNeedPoiFieldNumber = 40;
  inline const ::std::string& need_poi() const;
  inline void set_need_poi(const ::std::string& value);
  inline void set_need_poi(const char* value);
  inline void set_need_poi(const char* value, size_t size);
  inline ::std::string* mutable_need_poi();
  inline ::std::string* release_need_poi();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ASRequest)
 private:
  inline void set_has_is_new();
  inline void clear_has_is_new();
  inline void set_has_checkin_time();
  inline void clear_has_checkin_time();
  inline void set_has_checkout_time();
  inline void clear_has_checkout_time();
  inline void set_has_city_id();
  inline void clear_has_city_id();
  inline void set_has_channel_type();
  inline void clear_has_channel_type();
  inline void set_has_str_catg();
  inline void clear_has_str_catg();
  inline void set_has_str_subcatg();
  inline void clear_has_str_subcatg();
  inline void set_has_str_thdcatg();
  inline void clear_has_str_thdcatg();
  inline void set_has_str_shop_dist();
  inline void clear_has_str_shop_dist();
  inline void set_has_str_shop_range();
  inline void clear_has_str_shop_range();
  inline void set_has_str_sub_line();
  inline void clear_has_str_sub_line();
  inline void set_has_str_sub_station();
  inline void clear_has_str_sub_station();
  inline void set_has_str_site_list();
  inline void clear_has_str_site_list();
  inline void set_has_sort_type();
  inline void clear_has_sort_type();
  inline void set_has_start_idx();
  inline void clear_has_start_idx();
  inline void set_has_goods_per_page();
  inline void clear_has_goods_per_page();
  inline void set_has_good_num();
  inline void clear_has_good_num();
  inline void set_has_poi_per_page();
  inline void clear_has_poi_per_page();
  inline void set_has_poi_num();
  inline void clear_has_poi_num();
  inline void set_has_goods_per_poi();
  inline void clear_has_goods_per_poi();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_baidu_id();
  inline void clear_has_baidu_id();
  inline void set_has_is_expired();
  inline void clear_has_is_expired();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_keywords();
  inline void clear_has_keywords();
  inline void set_has_is_goflush();
  inline void clear_has_is_goflush();
  inline void set_has_tags();
  inline void clear_has_tags();
  inline void set_has_border();
  inline void clear_has_border();
  inline void set_has_border_start_distance();
  inline void clear_has_border_start_distance();
  inline void set_has_border_distance();
  inline void clear_has_border_distance();
  inline void set_has_verbose();
  inline void clear_has_verbose();
  inline void set_has_coor_sys();
  inline void clear_has_coor_sys();
  inline void set_has_nearby_id();
  inline void clear_has_nearby_id();
  inline void set_has_str_customized_location();
  inline void clear_has_str_customized_location();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_need_poi();
  inline void clear_has_need_poi();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 is_new_;
  ::google::protobuf::int32 checkin_time_;
  ::google::protobuf::int32 checkout_time_;
  ::google::protobuf::int32 channel_type_;
  ::google::protobuf::int64 city_id_;
  ::std::string* str_catg_;
  static const ::std::string _default_str_catg_;
  ::std::string* str_subcatg_;
  static const ::std::string _default_str_subcatg_;
  ::std::string* str_thdcatg_;
  static const ::std::string _default_str_thdcatg_;
  ::std::string* str_shop_dist_;
  static const ::std::string _default_str_shop_dist_;
  ::std::string* str_shop_range_;
  static const ::std::string _default_str_shop_range_;
  ::std::string* str_sub_line_;
  ::std::string* str_sub_station_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sub_station_;
  ::std::string* str_site_list_;
  static const ::std::string _default_str_site_list_;
  ::google::protobuf::int32 sort_type_;
  ::google::protobuf::int32 start_idx_;
  ::google::protobuf::int32 goods_per_page_;
  ::google::protobuf::int32 good_num_;
  ::google::protobuf::int32 poi_per_page_;
  ::google::protobuf::int32 poi_num_;
  ::std::string* cuid_;
  ::google::protobuf::int32 goods_per_poi_;
  ::google::protobuf::int32 client_;
  ::std::string* s_;
  static const ::std::string _default_s_;
  ::std::string* baidu_id_;
  ::std::string* location_;
  ::google::protobuf::int32 is_expired_;
  ::google::protobuf::int32 is_goflush_;
  ::std::string* keywords_;
  ::std::string* tags_;
  ::std::string* border_;
  ::google::protobuf::int32 border_start_distance_;
  ::google::protobuf::int32 border_distance_;
  ::std::string* coor_sys_;
  static const ::std::string _default_coor_sys_;
  ::std::string* nearby_id_;
  ::std::string* str_customized_location_;
  ::std::string* userid_;
  ::std::string* need_poi_;
  static const ::std::string _default_need_poi_;
  ::google::protobuf::int32 verbose_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];
  
  friend void  protobuf_AddDesc_as_2eproto();
  friend void protobuf_AssignDesc_as_2eproto();
  friend void protobuf_ShutdownFile_as_2eproto();
  
  void InitAsDefaultInstance();
  static ASRequest* default_instance_;
};
// -------------------------------------------------------------------

class ASFacetDetail : public ::google::protobuf::Message {
 public:
  ASFacetDetail();
  virtual ~ASFacetDetail();
  
  ASFacetDetail(const ASFacetDetail& from);
  
  inline ASFacetDetail& operator=(const ASFacetDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ASFacetDetail& default_instance();
  
  void Swap(ASFacetDetail* other);
  
  // implements Message ----------------------------------------------
  
  ASFacetDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASFacetDetail& from);
  void MergeFrom(const ASFacetDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string catg = 1;
  inline bool has_catg() const;
  inline void clear_catg();
  static const int kCatgFieldNumber = 1;
  inline const ::std::string& catg() const;
  inline void set_catg(const ::std::string& value);
  inline void set_catg(const char* value);
  inline void set_catg(const char* value, size_t size);
  inline ::std::string* mutable_catg();
  inline ::std::string* release_catg();
  
  // optional string city = 2;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 2;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  
  // optional string range = 3;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 3;
  inline const ::std::string& range() const;
  inline void set_range(const ::std::string& value);
  inline void set_range(const char* value);
  inline void set_range(const char* value, size_t size);
  inline ::std::string* mutable_range();
  inline ::std::string* release_range();
  
  // optional string dist = 4;
  inline bool has_dist() const;
  inline void clear_dist();
  static const int kDistFieldNumber = 4;
  inline const ::std::string& dist() const;
  inline void set_dist(const ::std::string& value);
  inline void set_dist(const char* value);
  inline void set_dist(const char* value, size_t size);
  inline ::std::string* mutable_dist();
  inline ::std::string* release_dist();
  
  // optional string subcatg = 5;
  inline bool has_subcatg() const;
  inline void clear_subcatg();
  static const int kSubcatgFieldNumber = 5;
  inline const ::std::string& subcatg() const;
  inline void set_subcatg(const ::std::string& value);
  inline void set_subcatg(const char* value);
  inline void set_subcatg(const char* value, size_t size);
  inline ::std::string* mutable_subcatg();
  inline ::std::string* release_subcatg();
  
  // optional string thirdcatg = 6;
  inline bool has_thirdcatg() const;
  inline void clear_thirdcatg();
  static const int kThirdcatgFieldNumber = 6;
  inline const ::std::string& thirdcatg() const;
  inline void set_thirdcatg(const ::std::string& value);
  inline void set_thirdcatg(const char* value);
  inline void set_thirdcatg(const char* value, size_t size);
  inline ::std::string* mutable_thirdcatg();
  inline ::std::string* release_thirdcatg();
  
  // optional string tags = 7;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 7;
  inline const ::std::string& tags() const;
  inline void set_tags(const ::std::string& value);
  inline void set_tags(const char* value);
  inline void set_tags(const char* value, size_t size);
  inline ::std::string* mutable_tags();
  inline ::std::string* release_tags();
  
  // optional string subway_line = 8;
  inline bool has_subway_line() const;
  inline void clear_subway_line();
  static const int kSubwayLineFieldNumber = 8;
  inline const ::std::string& subway_line() const;
  inline void set_subway_line(const ::std::string& value);
  inline void set_subway_line(const char* value);
  inline void set_subway_line(const char* value, size_t size);
  inline ::std::string* mutable_subway_line();
  inline ::std::string* release_subway_line();
  
  // optional string subway_station = 9;
  inline bool has_subway_station() const;
  inline void clear_subway_station();
  static const int kSubwayStationFieldNumber = 9;
  inline const ::std::string& subway_station() const;
  inline void set_subway_station(const ::std::string& value);
  inline void set_subway_station(const char* value);
  inline void set_subway_station(const char* value, size_t size);
  inline ::std::string* mutable_subway_station();
  inline ::std::string* release_subway_station();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ASFacetDetail)
 private:
  inline void set_has_catg();
  inline void clear_has_catg();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_dist();
  inline void clear_has_dist();
  inline void set_has_subcatg();
  inline void clear_has_subcatg();
  inline void set_has_thirdcatg();
  inline void clear_has_thirdcatg();
  inline void set_has_tags();
  inline void clear_has_tags();
  inline void set_has_subway_line();
  inline void clear_has_subway_line();
  inline void set_has_subway_station();
  inline void clear_has_subway_station();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* catg_;
  ::std::string* city_;
  ::std::string* range_;
  ::std::string* dist_;
  ::std::string* subcatg_;
  ::std::string* thirdcatg_;
  ::std::string* tags_;
  ::std::string* subway_line_;
  ::std::string* subway_station_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_as_2eproto();
  friend void protobuf_AssignDesc_as_2eproto();
  friend void protobuf_ShutdownFile_as_2eproto();
  
  void InitAsDefaultInstance();
  static ASFacetDetail* default_instance_;
};
// -------------------------------------------------------------------

class ASPoiDetail : public ::google::protobuf::Message {
 public:
  ASPoiDetail();
  virtual ~ASPoiDetail();
  
  ASPoiDetail(const ASPoiDetail& from);
  
  inline ASPoiDetail& operator=(const ASPoiDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ASPoiDetail& default_instance();
  
  void Swap(ASPoiDetail* other);
  
  // implements Message ----------------------------------------------
  
  ASPoiDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASPoiDetail& from);
  void MergeFrom(const ASPoiDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 poiid = 1;
  inline bool has_poiid() const;
  inline void clear_poiid();
  static const int kPoiidFieldNumber = 1;
  inline ::google::protobuf::int32 poiid() const;
  inline void set_poiid(::google::protobuf::int32 value);
  
  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional int32 distance = 4;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 4;
  inline ::google::protobuf::int32 distance() const;
  inline void set_distance(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ASPoiDetail)
 private:
  inline void set_has_poiid();
  inline void clear_has_poiid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_distance();
  inline void clear_has_distance();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 poiid_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 distance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_as_2eproto();
  friend void protobuf_AssignDesc_as_2eproto();
  friend void protobuf_ShutdownFile_as_2eproto();
  
  void InitAsDefaultInstance();
  static ASPoiDetail* default_instance_;
};
// -------------------------------------------------------------------

class ASDistInfo : public ::google::protobuf::Message {
 public:
  ASDistInfo();
  virtual ~ASDistInfo();
  
  ASDistInfo(const ASDistInfo& from);
  
  inline ASDistInfo& operator=(const ASDistInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ASDistInfo& default_instance();
  
  void Swap(ASDistInfo* other);
  
  // implements Message ----------------------------------------------
  
  ASDistInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASDistInfo& from);
  void MergeFrom(const ASDistInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ASDistInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_as_2eproto();
  friend void protobuf_AssignDesc_as_2eproto();
  friend void protobuf_ShutdownFile_as_2eproto();
  
  void InitAsDefaultInstance();
  static ASDistInfo* default_instance_;
};
// -------------------------------------------------------------------

class ASDealDetail : public ::google::protobuf::Message {
 public:
  ASDealDetail();
  virtual ~ASDealDetail();
  
  ASDealDetail(const ASDealDetail& from);
  
  inline ASDealDetail& operator=(const ASDealDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ASDealDetail& default_instance();
  
  void Swap(ASDealDetail* other);
  
  // implements Message ----------------------------------------------
  
  ASDealDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASDealDetail& from);
  void MergeFrom(const ASDealDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string image = 2;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 2;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  
  // optional string mid_image = 3;
  inline bool has_mid_image() const;
  inline void clear_mid_image();
  static const int kMidImageFieldNumber = 3;
  inline const ::std::string& mid_image() const;
  inline void set_mid_image(const ::std::string& value);
  inline void set_mid_image(const char* value);
  inline void set_mid_image(const char* value, size_t size);
  inline ::std::string* mutable_mid_image();
  inline ::std::string* release_mid_image();
  
  // optional string tiny_image = 4;
  inline bool has_tiny_image() const;
  inline void clear_tiny_image();
  static const int kTinyImageFieldNumber = 4;
  inline const ::std::string& tiny_image() const;
  inline void set_tiny_image(const ::std::string& value);
  inline void set_tiny_image(const char* value);
  inline void set_tiny_image(const char* value, size_t size);
  inline ::std::string* mutable_tiny_image();
  inline ::std::string* release_tiny_image();
  
  // optional string business_title = 5;
  inline bool has_business_title() const;
  inline void clear_business_title();
  static const int kBusinessTitleFieldNumber = 5;
  inline const ::std::string& business_title() const;
  inline void set_business_title(const ::std::string& value);
  inline void set_business_title(const char* value);
  inline void set_business_title(const char* value, size_t size);
  inline ::std::string* mutable_business_title();
  inline ::std::string* release_business_title();
  
  // optional string medium_title = 6;
  inline bool has_medium_title() const;
  inline void clear_medium_title();
  static const int kMediumTitleFieldNumber = 6;
  inline const ::std::string& medium_title() const;
  inline void set_medium_title(const ::std::string& value);
  inline void set_medium_title(const char* value);
  inline void set_medium_title(const char* value, size_t size);
  inline ::std::string* mutable_medium_title();
  inline ::std::string* release_medium_title();
  
  // optional string title_high_price = 7;
  inline bool has_title_high_price() const;
  inline void clear_title_high_price();
  static const int kTitleHighPriceFieldNumber = 7;
  inline const ::std::string& title_high_price() const;
  inline void set_title_high_price(const ::std::string& value);
  inline void set_title_high_price(const char* value);
  inline void set_title_high_price(const char* value, size_t size);
  inline ::std::string* mutable_title_high_price();
  inline ::std::string* release_title_high_price();
  
  // optional string min_title = 8;
  inline bool has_min_title() const;
  inline void clear_min_title();
  static const int kMinTitleFieldNumber = 8;
  inline const ::std::string& min_title() const;
  inline void set_min_title(const ::std::string& value);
  inline void set_min_title(const char* value);
  inline void set_min_title(const char* value, size_t size);
  inline ::std::string* mutable_min_title();
  inline ::std::string* release_min_title();
  
  // optional int32 price_ori = 9;
  inline bool has_price_ori() const;
  inline void clear_price_ori();
  static const int kPriceOriFieldNumber = 9;
  inline ::google::protobuf::int32 price_ori() const;
  inline void set_price_ori(::google::protobuf::int32 value);
  
  // optional int32 price_current = 10;
  inline bool has_price_current() const;
  inline void clear_price_current();
  static const int kPriceCurrentFieldNumber = 10;
  inline ::google::protobuf::int32 price_current() const;
  inline void set_price_current(::google::protobuf::int32 value);
  
  // optional string tags = 11;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 11;
  inline const ::std::string& tags() const;
  inline void set_tags(const ::std::string& value);
  inline void set_tags(const char* value);
  inline void set_tags(const char* value, size_t size);
  inline ::std::string* mutable_tags();
  inline ::std::string* release_tags();
  
  // optional int32 is_new = 12;
  inline bool has_is_new() const;
  inline void clear_is_new();
  static const int kIsNewFieldNumber = 12;
  inline ::google::protobuf::int32 is_new() const;
  inline void set_is_new(::google::protobuf::int32 value);
  
  // optional int32 sale_count = 13;
  inline bool has_sale_count() const;
  inline void clear_sale_count();
  static const int kSaleCountFieldNumber = 13;
  inline ::google::protobuf::int32 sale_count() const;
  inline void set_sale_count(::google::protobuf::int32 value);
  
  // optional int32 type = 14;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 14;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional int32 pay_start_time = 15;
  inline bool has_pay_start_time() const;
  inline void clear_pay_start_time();
  static const int kPayStartTimeFieldNumber = 15;
  inline ::google::protobuf::int32 pay_start_time() const;
  inline void set_pay_start_time(::google::protobuf::int32 value);
  
  // optional int32 pay_end_time = 16;
  inline bool has_pay_end_time() const;
  inline void clear_pay_end_time();
  static const int kPayEndTimeFieldNumber = 16;
  inline ::google::protobuf::int32 pay_end_time() const;
  inline void set_pay_end_time(::google::protobuf::int32 value);
  
  // optional int32 deal_start_time = 17;
  inline bool has_deal_start_time() const;
  inline void clear_deal_start_time();
  static const int kDealStartTimeFieldNumber = 17;
  inline ::google::protobuf::int32 deal_start_time() const;
  inline void set_deal_start_time(::google::protobuf::int32 value);
  
  // optional int32 deal_expire_time = 18;
  inline bool has_deal_expire_time() const;
  inline void clear_deal_expire_time();
  static const int kDealExpireTimeFieldNumber = 18;
  inline ::google::protobuf::int32 deal_expire_time() const;
  inline void set_deal_expire_time(::google::protobuf::int32 value);
  
  // optional int32 city_num = 19;
  inline bool has_city_num() const;
  inline void clear_city_num();
  static const int kCityNumFieldNumber = 19;
  inline ::google::protobuf::int32 city_num() const;
  inline void set_city_num(::google::protobuf::int32 value);
  
  // optional int32 poi_num = 20;
  inline bool has_poi_num() const;
  inline void clear_poi_num();
  static const int kPoiNumFieldNumber = 20;
  inline ::google::protobuf::int32 poi_num() const;
  inline void set_poi_num(::google::protobuf::int32 value);
  
  // repeated .lbs.da.openservice.ASPoiDetail poi = 21;
  inline int poi_size() const;
  inline void clear_poi();
  static const int kPoiFieldNumber = 21;
  inline const ::lbs::da::openservice::ASPoiDetail& poi(int index) const;
  inline ::lbs::da::openservice::ASPoiDetail* mutable_poi(int index);
  inline ::lbs::da::openservice::ASPoiDetail* add_poi();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASPoiDetail >&
      poi() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASPoiDetail >*
      mutable_poi();
  
  // optional string range = 22;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 22;
  inline const ::std::string& range() const;
  inline void set_range(const ::std::string& value);
  inline void set_range(const char* value);
  inline void set_range(const char* value, size_t size);
  inline ::std::string* mutable_range();
  inline ::std::string* release_range();
  
  // optional int32 score = 23;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 23;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // optional int32 comment_num = 24;
  inline bool has_comment_num() const;
  inline void clear_comment_num();
  static const int kCommentNumFieldNumber = 24;
  inline ::google::protobuf::int32 comment_num() const;
  inline void set_comment_num(::google::protobuf::int32 value);
  
  // optional int32 bought_weekly = 25;
  inline bool has_bought_weekly() const;
  inline void clear_bought_weekly();
  static const int kBoughtWeeklyFieldNumber = 25;
  inline ::google::protobuf::int32 bought_weekly() const;
  inline void set_bought_weekly(::google::protobuf::int32 value);
  
  // optional string tiny_url = 26;
  inline bool has_tiny_url() const;
  inline void clear_tiny_url();
  static const int kTinyUrlFieldNumber = 26;
  inline const ::std::string& tiny_url() const;
  inline void set_tiny_url(const ::std::string& value);
  inline void set_tiny_url(const char* value);
  inline void set_tiny_url(const char* value, size_t size);
  inline ::std::string* mutable_tiny_url();
  inline ::std::string* release_tiny_url();
  
  // optional .lbs.da.openservice.ASDistInfo dist_info = 27;
  inline bool has_dist_info() const;
  inline void clear_dist_info();
  static const int kDistInfoFieldNumber = 27;
  inline const ::lbs::da::openservice::ASDistInfo& dist_info() const;
  inline ::lbs::da::openservice::ASDistInfo* mutable_dist_info();
  inline ::lbs::da::openservice::ASDistInfo* release_dist_info();
  
  // optional int32 is_national = 28;
  inline bool has_is_national() const;
  inline void clear_is_national();
  static const int kIsNationalFieldNumber = 28;
  inline ::google::protobuf::int32 is_national() const;
  inline void set_is_national(::google::protobuf::int32 value);
  
  // optional int32 num_brother = 29;
  inline bool has_num_brother() const;
  inline void clear_num_brother();
  static const int kNumBrotherFieldNumber = 29;
  inline ::google::protobuf::int32 num_brother() const;
  inline void set_num_brother(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ASDealDetail)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_mid_image();
  inline void clear_has_mid_image();
  inline void set_has_tiny_image();
  inline void clear_has_tiny_image();
  inline void set_has_business_title();
  inline void clear_has_business_title();
  inline void set_has_medium_title();
  inline void clear_has_medium_title();
  inline void set_has_title_high_price();
  inline void clear_has_title_high_price();
  inline void set_has_min_title();
  inline void clear_has_min_title();
  inline void set_has_price_ori();
  inline void clear_has_price_ori();
  inline void set_has_price_current();
  inline void clear_has_price_current();
  inline void set_has_tags();
  inline void clear_has_tags();
  inline void set_has_is_new();
  inline void clear_has_is_new();
  inline void set_has_sale_count();
  inline void clear_has_sale_count();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pay_start_time();
  inline void clear_has_pay_start_time();
  inline void set_has_pay_end_time();
  inline void clear_has_pay_end_time();
  inline void set_has_deal_start_time();
  inline void clear_has_deal_start_time();
  inline void set_has_deal_expire_time();
  inline void clear_has_deal_expire_time();
  inline void set_has_city_num();
  inline void clear_has_city_num();
  inline void set_has_poi_num();
  inline void clear_has_poi_num();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_comment_num();
  inline void clear_has_comment_num();
  inline void set_has_bought_weekly();
  inline void clear_has_bought_weekly();
  inline void set_has_tiny_url();
  inline void clear_has_tiny_url();
  inline void set_has_dist_info();
  inline void clear_has_dist_info();
  inline void set_has_is_national();
  inline void clear_has_is_national();
  inline void set_has_num_brother();
  inline void clear_has_num_brother();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* image_;
  ::std::string* mid_image_;
  ::std::string* tiny_image_;
  ::std::string* business_title_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 price_ori_;
  ::std::string* medium_title_;
  ::std::string* title_high_price_;
  ::std::string* min_title_;
  ::std::string* tags_;
  ::google::protobuf::int32 price_current_;
  ::google::protobuf::int32 is_new_;
  ::google::protobuf::int32 sale_count_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 pay_start_time_;
  ::google::protobuf::int32 pay_end_time_;
  ::google::protobuf::int32 deal_start_time_;
  ::google::protobuf::int32 deal_expire_time_;
  ::google::protobuf::int32 city_num_;
  ::google::protobuf::int32 poi_num_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASPoiDetail > poi_;
  ::std::string* range_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 comment_num_;
  ::std::string* tiny_url_;
  ::google::protobuf::int32 bought_weekly_;
  ::google::protobuf::int32 is_national_;
  ::lbs::da::openservice::ASDistInfo* dist_info_;
  ::google::protobuf::int32 num_brother_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];
  
  friend void  protobuf_AddDesc_as_2eproto();
  friend void protobuf_AssignDesc_as_2eproto();
  friend void protobuf_ShutdownFile_as_2eproto();
  
  void InitAsDefaultInstance();
  static ASDealDetail* default_instance_;
};
// -------------------------------------------------------------------

class ASResponse : public ::google::protobuf::Message {
 public:
  ASResponse();
  virtual ~ASResponse();
  
  ASResponse(const ASResponse& from);
  
  inline ASResponse& operator=(const ASResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ASResponse& default_instance();
  
  void Swap(ASResponse* other);
  
  // implements Message ----------------------------------------------
  
  ASResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASResponse& from);
  void MergeFrom(const ASResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // optional string head_data = 2;
  inline bool has_head_data() const;
  inline void clear_head_data();
  static const int kHeadDataFieldNumber = 2;
  inline const ::std::string& head_data() const;
  inline void set_head_data(const ::std::string& value);
  inline void set_head_data(const char* value);
  inline void set_head_data(const char* value, size_t size);
  inline ::std::string* mutable_head_data();
  inline ::std::string* release_head_data();
  
  // optional .lbs.da.openservice.ASFacetDetail facet = 3;
  inline bool has_facet() const;
  inline void clear_facet();
  static const int kFacetFieldNumber = 3;
  inline const ::lbs::da::openservice::ASFacetDetail& facet() const;
  inline ::lbs::da::openservice::ASFacetDetail* mutable_facet();
  inline ::lbs::da::openservice::ASFacetDetail* release_facet();
  
  // optional int32 total = 4;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 4;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);
  
  // optional string remain = 5;
  inline bool has_remain() const;
  inline void clear_remain();
  static const int kRemainFieldNumber = 5;
  inline const ::std::string& remain() const;
  inline void set_remain(const ::std::string& value);
  inline void set_remain(const char* value);
  inline void set_remain(const char* value, size_t size);
  inline ::std::string* mutable_remain();
  inline ::std::string* release_remain();
  
  // optional string landmark_distance = 6;
  inline bool has_landmark_distance() const;
  inline void clear_landmark_distance();
  static const int kLandmarkDistanceFieldNumber = 6;
  inline const ::std::string& landmark_distance() const;
  inline void set_landmark_distance(const ::std::string& value);
  inline void set_landmark_distance(const char* value);
  inline void set_landmark_distance(const char* value, size_t size);
  inline ::std::string* mutable_landmark_distance();
  inline ::std::string* release_landmark_distance();
  
  // optional string nearby_distance = 7;
  inline bool has_nearby_distance() const;
  inline void clear_nearby_distance();
  static const int kNearbyDistanceFieldNumber = 7;
  inline const ::std::string& nearby_distance() const;
  inline void set_nearby_distance(const ::std::string& value);
  inline void set_nearby_distance(const char* value);
  inline void set_nearby_distance(const char* value, size_t size);
  inline ::std::string* mutable_nearby_distance();
  inline ::std::string* release_nearby_distance();
  
  // optional int32 query_dist = 8;
  inline bool has_query_dist() const;
  inline void clear_query_dist();
  static const int kQueryDistFieldNumber = 8;
  inline ::google::protobuf::int32 query_dist() const;
  inline void set_query_dist(::google::protobuf::int32 value);
  
  // optional int32 query_range = 9;
  inline bool has_query_range() const;
  inline void clear_query_range();
  static const int kQueryRangeFieldNumber = 9;
  inline ::google::protobuf::int32 query_range() const;
  inline void set_query_range(::google::protobuf::int32 value);
  
  // optional string highlights = 10;
  inline bool has_highlights() const;
  inline void clear_highlights();
  static const int kHighlightsFieldNumber = 10;
  inline const ::std::string& highlights() const;
  inline void set_highlights(const ::std::string& value);
  inline void set_highlights(const char* value);
  inline void set_highlights(const char* value, size_t size);
  inline ::std::string* mutable_highlights();
  inline ::std::string* release_highlights();
  
  // optional int32 expired_amount = 11;
  inline bool has_expired_amount() const;
  inline void clear_expired_amount();
  static const int kExpiredAmountFieldNumber = 11;
  inline ::google::protobuf::int32 expired_amount() const;
  inline void set_expired_amount(::google::protobuf::int32 value);
  
  // repeated .lbs.da.openservice.ASDealDetail detail = 12;
  inline int detail_size() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 12;
  inline const ::lbs::da::openservice::ASDealDetail& detail(int index) const;
  inline ::lbs::da::openservice::ASDealDetail* mutable_detail(int index);
  inline ::lbs::da::openservice::ASDealDetail* add_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASDealDetail >&
      detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASDealDetail >*
      mutable_detail();
  
  // optional string exp_ids = 13;
  inline bool has_exp_ids() const;
  inline void clear_exp_ids();
  static const int kExpIdsFieldNumber = 13;
  inline const ::std::string& exp_ids() const;
  inline void set_exp_ids(const ::std::string& value);
  inline void set_exp_ids(const char* value);
  inline void set_exp_ids(const char* value, size_t size);
  inline ::std::string* mutable_exp_ids();
  inline ::std::string* release_exp_ids();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ASResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_head_data();
  inline void clear_has_head_data();
  inline void set_has_facet();
  inline void clear_has_facet();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_remain();
  inline void clear_has_remain();
  inline void set_has_landmark_distance();
  inline void clear_has_landmark_distance();
  inline void set_has_nearby_distance();
  inline void clear_has_nearby_distance();
  inline void set_has_query_dist();
  inline void clear_has_query_dist();
  inline void set_has_query_range();
  inline void clear_has_query_range();
  inline void set_has_highlights();
  inline void clear_has_highlights();
  inline void set_has_expired_amount();
  inline void clear_has_expired_amount();
  inline void set_has_exp_ids();
  inline void clear_has_exp_ids();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  ::std::string* head_data_;
  ::lbs::da::openservice::ASFacetDetail* facet_;
  ::std::string* remain_;
  ::std::string* landmark_distance_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 query_dist_;
  ::std::string* nearby_distance_;
  ::std::string* highlights_;
  ::google::protobuf::int32 query_range_;
  ::google::protobuf::int32 expired_amount_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASDealDetail > detail_;
  ::std::string* exp_ids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_as_2eproto();
  friend void protobuf_AssignDesc_as_2eproto();
  friend void protobuf_ShutdownFile_as_2eproto();
  
  void InitAsDefaultInstance();
  static ASResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ASRequest

// optional int32 is_new = 1 [default = 0];
inline bool ASRequest::has_is_new() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASRequest::set_has_is_new() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASRequest::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASRequest::clear_is_new() {
  is_new_ = 0;
  clear_has_is_new();
}
inline ::google::protobuf::int32 ASRequest::is_new() const {
  return is_new_;
}
inline void ASRequest::set_is_new(::google::protobuf::int32 value) {
  set_has_is_new();
  is_new_ = value;
}

// optional int32 checkin_time = 2 [default = -1];
inline bool ASRequest::has_checkin_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASRequest::set_has_checkin_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASRequest::clear_has_checkin_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASRequest::clear_checkin_time() {
  checkin_time_ = -1;
  clear_has_checkin_time();
}
inline ::google::protobuf::int32 ASRequest::checkin_time() const {
  return checkin_time_;
}
inline void ASRequest::set_checkin_time(::google::protobuf::int32 value) {
  set_has_checkin_time();
  checkin_time_ = value;
}

// optional int32 checkout_time = 3 [default = -1];
inline bool ASRequest::has_checkout_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASRequest::set_has_checkout_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASRequest::clear_has_checkout_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASRequest::clear_checkout_time() {
  checkout_time_ = -1;
  clear_has_checkout_time();
}
inline ::google::protobuf::int32 ASRequest::checkout_time() const {
  return checkout_time_;
}
inline void ASRequest::set_checkout_time(::google::protobuf::int32 value) {
  set_has_checkout_time();
  checkout_time_ = value;
}

// optional int64 city_id = 4;
inline bool ASRequest::has_city_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASRequest::set_has_city_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASRequest::clear_has_city_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASRequest::clear_city_id() {
  city_id_ = GOOGLE_LONGLONG(0);
  clear_has_city_id();
}
inline ::google::protobuf::int64 ASRequest::city_id() const {
  return city_id_;
}
inline void ASRequest::set_city_id(::google::protobuf::int64 value) {
  set_has_city_id();
  city_id_ = value;
}

// optional int32 channel_type = 5 [default = 8];
inline bool ASRequest::has_channel_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ASRequest::set_has_channel_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ASRequest::clear_has_channel_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ASRequest::clear_channel_type() {
  channel_type_ = 8;
  clear_has_channel_type();
}
inline ::google::protobuf::int32 ASRequest::channel_type() const {
  return channel_type_;
}
inline void ASRequest::set_channel_type(::google::protobuf::int32 value) {
  set_has_channel_type();
  channel_type_ = value;
}

// optional string str_catg = 6 [default = "0"];
inline bool ASRequest::has_str_catg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ASRequest::set_has_str_catg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ASRequest::clear_has_str_catg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ASRequest::clear_str_catg() {
  if (str_catg_ != &_default_str_catg_) {
    str_catg_->assign(_default_str_catg_);
  }
  clear_has_str_catg();
}
inline const ::std::string& ASRequest::str_catg() const {
  return *str_catg_;
}
inline void ASRequest::set_str_catg(const ::std::string& value) {
  set_has_str_catg();
  if (str_catg_ == &_default_str_catg_) {
    str_catg_ = new ::std::string;
  }
  str_catg_->assign(value);
}
inline void ASRequest::set_str_catg(const char* value) {
  set_has_str_catg();
  if (str_catg_ == &_default_str_catg_) {
    str_catg_ = new ::std::string;
  }
  str_catg_->assign(value);
}
inline void ASRequest::set_str_catg(const char* value, size_t size) {
  set_has_str_catg();
  if (str_catg_ == &_default_str_catg_) {
    str_catg_ = new ::std::string;
  }
  str_catg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_catg() {
  set_has_str_catg();
  if (str_catg_ == &_default_str_catg_) {
    str_catg_ = new ::std::string(_default_str_catg_);
  }
  return str_catg_;
}
inline ::std::string* ASRequest::release_str_catg() {
  clear_has_str_catg();
  if (str_catg_ == &_default_str_catg_) {
    return NULL;
  } else {
    ::std::string* temp = str_catg_;
    str_catg_ = const_cast< ::std::string*>(&_default_str_catg_);
    return temp;
  }
}

// optional string str_subcatg = 7 [default = "0"];
inline bool ASRequest::has_str_subcatg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ASRequest::set_has_str_subcatg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ASRequest::clear_has_str_subcatg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ASRequest::clear_str_subcatg() {
  if (str_subcatg_ != &_default_str_subcatg_) {
    str_subcatg_->assign(_default_str_subcatg_);
  }
  clear_has_str_subcatg();
}
inline const ::std::string& ASRequest::str_subcatg() const {
  return *str_subcatg_;
}
inline void ASRequest::set_str_subcatg(const ::std::string& value) {
  set_has_str_subcatg();
  if (str_subcatg_ == &_default_str_subcatg_) {
    str_subcatg_ = new ::std::string;
  }
  str_subcatg_->assign(value);
}
inline void ASRequest::set_str_subcatg(const char* value) {
  set_has_str_subcatg();
  if (str_subcatg_ == &_default_str_subcatg_) {
    str_subcatg_ = new ::std::string;
  }
  str_subcatg_->assign(value);
}
inline void ASRequest::set_str_subcatg(const char* value, size_t size) {
  set_has_str_subcatg();
  if (str_subcatg_ == &_default_str_subcatg_) {
    str_subcatg_ = new ::std::string;
  }
  str_subcatg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_subcatg() {
  set_has_str_subcatg();
  if (str_subcatg_ == &_default_str_subcatg_) {
    str_subcatg_ = new ::std::string(_default_str_subcatg_);
  }
  return str_subcatg_;
}
inline ::std::string* ASRequest::release_str_subcatg() {
  clear_has_str_subcatg();
  if (str_subcatg_ == &_default_str_subcatg_) {
    return NULL;
  } else {
    ::std::string* temp = str_subcatg_;
    str_subcatg_ = const_cast< ::std::string*>(&_default_str_subcatg_);
    return temp;
  }
}

// optional string str_thdcatg = 8 [default = "0"];
inline bool ASRequest::has_str_thdcatg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ASRequest::set_has_str_thdcatg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ASRequest::clear_has_str_thdcatg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ASRequest::clear_str_thdcatg() {
  if (str_thdcatg_ != &_default_str_thdcatg_) {
    str_thdcatg_->assign(_default_str_thdcatg_);
  }
  clear_has_str_thdcatg();
}
inline const ::std::string& ASRequest::str_thdcatg() const {
  return *str_thdcatg_;
}
inline void ASRequest::set_str_thdcatg(const ::std::string& value) {
  set_has_str_thdcatg();
  if (str_thdcatg_ == &_default_str_thdcatg_) {
    str_thdcatg_ = new ::std::string;
  }
  str_thdcatg_->assign(value);
}
inline void ASRequest::set_str_thdcatg(const char* value) {
  set_has_str_thdcatg();
  if (str_thdcatg_ == &_default_str_thdcatg_) {
    str_thdcatg_ = new ::std::string;
  }
  str_thdcatg_->assign(value);
}
inline void ASRequest::set_str_thdcatg(const char* value, size_t size) {
  set_has_str_thdcatg();
  if (str_thdcatg_ == &_default_str_thdcatg_) {
    str_thdcatg_ = new ::std::string;
  }
  str_thdcatg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_thdcatg() {
  set_has_str_thdcatg();
  if (str_thdcatg_ == &_default_str_thdcatg_) {
    str_thdcatg_ = new ::std::string(_default_str_thdcatg_);
  }
  return str_thdcatg_;
}
inline ::std::string* ASRequest::release_str_thdcatg() {
  clear_has_str_thdcatg();
  if (str_thdcatg_ == &_default_str_thdcatg_) {
    return NULL;
  } else {
    ::std::string* temp = str_thdcatg_;
    str_thdcatg_ = const_cast< ::std::string*>(&_default_str_thdcatg_);
    return temp;
  }
}

// optional string str_shop_dist = 9 [default = "0"];
inline bool ASRequest::has_str_shop_dist() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ASRequest::set_has_str_shop_dist() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ASRequest::clear_has_str_shop_dist() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ASRequest::clear_str_shop_dist() {
  if (str_shop_dist_ != &_default_str_shop_dist_) {
    str_shop_dist_->assign(_default_str_shop_dist_);
  }
  clear_has_str_shop_dist();
}
inline const ::std::string& ASRequest::str_shop_dist() const {
  return *str_shop_dist_;
}
inline void ASRequest::set_str_shop_dist(const ::std::string& value) {
  set_has_str_shop_dist();
  if (str_shop_dist_ == &_default_str_shop_dist_) {
    str_shop_dist_ = new ::std::string;
  }
  str_shop_dist_->assign(value);
}
inline void ASRequest::set_str_shop_dist(const char* value) {
  set_has_str_shop_dist();
  if (str_shop_dist_ == &_default_str_shop_dist_) {
    str_shop_dist_ = new ::std::string;
  }
  str_shop_dist_->assign(value);
}
inline void ASRequest::set_str_shop_dist(const char* value, size_t size) {
  set_has_str_shop_dist();
  if (str_shop_dist_ == &_default_str_shop_dist_) {
    str_shop_dist_ = new ::std::string;
  }
  str_shop_dist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_shop_dist() {
  set_has_str_shop_dist();
  if (str_shop_dist_ == &_default_str_shop_dist_) {
    str_shop_dist_ = new ::std::string(_default_str_shop_dist_);
  }
  return str_shop_dist_;
}
inline ::std::string* ASRequest::release_str_shop_dist() {
  clear_has_str_shop_dist();
  if (str_shop_dist_ == &_default_str_shop_dist_) {
    return NULL;
  } else {
    ::std::string* temp = str_shop_dist_;
    str_shop_dist_ = const_cast< ::std::string*>(&_default_str_shop_dist_);
    return temp;
  }
}

// optional string str_shop_range = 10 [default = "0"];
inline bool ASRequest::has_str_shop_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ASRequest::set_has_str_shop_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ASRequest::clear_has_str_shop_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ASRequest::clear_str_shop_range() {
  if (str_shop_range_ != &_default_str_shop_range_) {
    str_shop_range_->assign(_default_str_shop_range_);
  }
  clear_has_str_shop_range();
}
inline const ::std::string& ASRequest::str_shop_range() const {
  return *str_shop_range_;
}
inline void ASRequest::set_str_shop_range(const ::std::string& value) {
  set_has_str_shop_range();
  if (str_shop_range_ == &_default_str_shop_range_) {
    str_shop_range_ = new ::std::string;
  }
  str_shop_range_->assign(value);
}
inline void ASRequest::set_str_shop_range(const char* value) {
  set_has_str_shop_range();
  if (str_shop_range_ == &_default_str_shop_range_) {
    str_shop_range_ = new ::std::string;
  }
  str_shop_range_->assign(value);
}
inline void ASRequest::set_str_shop_range(const char* value, size_t size) {
  set_has_str_shop_range();
  if (str_shop_range_ == &_default_str_shop_range_) {
    str_shop_range_ = new ::std::string;
  }
  str_shop_range_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_shop_range() {
  set_has_str_shop_range();
  if (str_shop_range_ == &_default_str_shop_range_) {
    str_shop_range_ = new ::std::string(_default_str_shop_range_);
  }
  return str_shop_range_;
}
inline ::std::string* ASRequest::release_str_shop_range() {
  clear_has_str_shop_range();
  if (str_shop_range_ == &_default_str_shop_range_) {
    return NULL;
  } else {
    ::std::string* temp = str_shop_range_;
    str_shop_range_ = const_cast< ::std::string*>(&_default_str_shop_range_);
    return temp;
  }
}

// optional string str_sub_line = 11;
inline bool ASRequest::has_str_sub_line() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ASRequest::set_has_str_sub_line() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ASRequest::clear_has_str_sub_line() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ASRequest::clear_str_sub_line() {
  if (str_sub_line_ != &::google::protobuf::internal::kEmptyString) {
    str_sub_line_->clear();
  }
  clear_has_str_sub_line();
}
inline const ::std::string& ASRequest::str_sub_line() const {
  return *str_sub_line_;
}
inline void ASRequest::set_str_sub_line(const ::std::string& value) {
  set_has_str_sub_line();
  if (str_sub_line_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_line_ = new ::std::string;
  }
  str_sub_line_->assign(value);
}
inline void ASRequest::set_str_sub_line(const char* value) {
  set_has_str_sub_line();
  if (str_sub_line_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_line_ = new ::std::string;
  }
  str_sub_line_->assign(value);
}
inline void ASRequest::set_str_sub_line(const char* value, size_t size) {
  set_has_str_sub_line();
  if (str_sub_line_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_line_ = new ::std::string;
  }
  str_sub_line_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_sub_line() {
  set_has_str_sub_line();
  if (str_sub_line_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_line_ = new ::std::string;
  }
  return str_sub_line_;
}
inline ::std::string* ASRequest::release_str_sub_line() {
  clear_has_str_sub_line();
  if (str_sub_line_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_sub_line_;
    str_sub_line_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string str_sub_station = 12;
inline bool ASRequest::has_str_sub_station() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ASRequest::set_has_str_sub_station() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ASRequest::clear_has_str_sub_station() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ASRequest::clear_str_sub_station() {
  if (str_sub_station_ != &::google::protobuf::internal::kEmptyString) {
    str_sub_station_->clear();
  }
  clear_has_str_sub_station();
}
inline const ::std::string& ASRequest::str_sub_station() const {
  return *str_sub_station_;
}
inline void ASRequest::set_str_sub_station(const ::std::string& value) {
  set_has_str_sub_station();
  if (str_sub_station_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_station_ = new ::std::string;
  }
  str_sub_station_->assign(value);
}
inline void ASRequest::set_str_sub_station(const char* value) {
  set_has_str_sub_station();
  if (str_sub_station_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_station_ = new ::std::string;
  }
  str_sub_station_->assign(value);
}
inline void ASRequest::set_str_sub_station(const char* value, size_t size) {
  set_has_str_sub_station();
  if (str_sub_station_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_station_ = new ::std::string;
  }
  str_sub_station_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_sub_station() {
  set_has_str_sub_station();
  if (str_sub_station_ == &::google::protobuf::internal::kEmptyString) {
    str_sub_station_ = new ::std::string;
  }
  return str_sub_station_;
}
inline ::std::string* ASRequest::release_str_sub_station() {
  clear_has_str_sub_station();
  if (str_sub_station_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_sub_station_;
    str_sub_station_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 sub_station = 13;
inline int ASRequest::sub_station_size() const {
  return sub_station_.size();
}
inline void ASRequest::clear_sub_station() {
  sub_station_.Clear();
}
inline ::google::protobuf::int32 ASRequest::sub_station(int index) const {
  return sub_station_.Get(index);
}
inline void ASRequest::set_sub_station(int index, ::google::protobuf::int32 value) {
  sub_station_.Set(index, value);
}
inline void ASRequest::add_sub_station(::google::protobuf::int32 value) {
  sub_station_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ASRequest::sub_station() const {
  return sub_station_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ASRequest::mutable_sub_station() {
  return &sub_station_;
}

// optional string str_site_list = 14 [default = "0"];
inline bool ASRequest::has_str_site_list() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ASRequest::set_has_str_site_list() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ASRequest::clear_has_str_site_list() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ASRequest::clear_str_site_list() {
  if (str_site_list_ != &_default_str_site_list_) {
    str_site_list_->assign(_default_str_site_list_);
  }
  clear_has_str_site_list();
}
inline const ::std::string& ASRequest::str_site_list() const {
  return *str_site_list_;
}
inline void ASRequest::set_str_site_list(const ::std::string& value) {
  set_has_str_site_list();
  if (str_site_list_ == &_default_str_site_list_) {
    str_site_list_ = new ::std::string;
  }
  str_site_list_->assign(value);
}
inline void ASRequest::set_str_site_list(const char* value) {
  set_has_str_site_list();
  if (str_site_list_ == &_default_str_site_list_) {
    str_site_list_ = new ::std::string;
  }
  str_site_list_->assign(value);
}
inline void ASRequest::set_str_site_list(const char* value, size_t size) {
  set_has_str_site_list();
  if (str_site_list_ == &_default_str_site_list_) {
    str_site_list_ = new ::std::string;
  }
  str_site_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_site_list() {
  set_has_str_site_list();
  if (str_site_list_ == &_default_str_site_list_) {
    str_site_list_ = new ::std::string(_default_str_site_list_);
  }
  return str_site_list_;
}
inline ::std::string* ASRequest::release_str_site_list() {
  clear_has_str_site_list();
  if (str_site_list_ == &_default_str_site_list_) {
    return NULL;
  } else {
    ::std::string* temp = str_site_list_;
    str_site_list_ = const_cast< ::std::string*>(&_default_str_site_list_);
    return temp;
  }
}

// optional int32 sort_type = 15 [default = 0];
inline bool ASRequest::has_sort_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ASRequest::set_has_sort_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ASRequest::clear_has_sort_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ASRequest::clear_sort_type() {
  sort_type_ = 0;
  clear_has_sort_type();
}
inline ::google::protobuf::int32 ASRequest::sort_type() const {
  return sort_type_;
}
inline void ASRequest::set_sort_type(::google::protobuf::int32 value) {
  set_has_sort_type();
  sort_type_ = value;
}

// optional int32 start_idx = 16 [default = 1];
inline bool ASRequest::has_start_idx() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ASRequest::set_has_start_idx() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ASRequest::clear_has_start_idx() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ASRequest::clear_start_idx() {
  start_idx_ = 1;
  clear_has_start_idx();
}
inline ::google::protobuf::int32 ASRequest::start_idx() const {
  return start_idx_;
}
inline void ASRequest::set_start_idx(::google::protobuf::int32 value) {
  set_has_start_idx();
  start_idx_ = value;
}

// optional int32 goods_per_page = 17 [default = 91];
inline bool ASRequest::has_goods_per_page() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ASRequest::set_has_goods_per_page() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ASRequest::clear_has_goods_per_page() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ASRequest::clear_goods_per_page() {
  goods_per_page_ = 91;
  clear_has_goods_per_page();
}
inline ::google::protobuf::int32 ASRequest::goods_per_page() const {
  return goods_per_page_;
}
inline void ASRequest::set_goods_per_page(::google::protobuf::int32 value) {
  set_has_goods_per_page();
  goods_per_page_ = value;
}

// optional int32 good_num = 18 [default = 91];
inline bool ASRequest::has_good_num() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ASRequest::set_has_good_num() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ASRequest::clear_has_good_num() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ASRequest::clear_good_num() {
  good_num_ = 91;
  clear_has_good_num();
}
inline ::google::protobuf::int32 ASRequest::good_num() const {
  return good_num_;
}
inline void ASRequest::set_good_num(::google::protobuf::int32 value) {
  set_has_good_num();
  good_num_ = value;
}

// optional int32 poi_per_page = 19 [default = 10];
inline bool ASRequest::has_poi_per_page() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ASRequest::set_has_poi_per_page() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ASRequest::clear_has_poi_per_page() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ASRequest::clear_poi_per_page() {
  poi_per_page_ = 10;
  clear_has_poi_per_page();
}
inline ::google::protobuf::int32 ASRequest::poi_per_page() const {
  return poi_per_page_;
}
inline void ASRequest::set_poi_per_page(::google::protobuf::int32 value) {
  set_has_poi_per_page();
  poi_per_page_ = value;
}

// optional int32 poi_num = 20 [default = 20];
inline bool ASRequest::has_poi_num() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ASRequest::set_has_poi_num() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ASRequest::clear_has_poi_num() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ASRequest::clear_poi_num() {
  poi_num_ = 20;
  clear_has_poi_num();
}
inline ::google::protobuf::int32 ASRequest::poi_num() const {
  return poi_num_;
}
inline void ASRequest::set_poi_num(::google::protobuf::int32 value) {
  set_has_poi_num();
  poi_num_ = value;
}

// optional int32 goods_per_poi = 21 [default = 10];
inline bool ASRequest::has_goods_per_poi() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ASRequest::set_has_goods_per_poi() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ASRequest::clear_has_goods_per_poi() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ASRequest::clear_goods_per_poi() {
  goods_per_poi_ = 10;
  clear_has_goods_per_poi();
}
inline ::google::protobuf::int32 ASRequest::goods_per_poi() const {
  return goods_per_poi_;
}
inline void ASRequest::set_goods_per_poi(::google::protobuf::int32 value) {
  set_has_goods_per_poi();
  goods_per_poi_ = value;
}

// optional string cuid = 22 [default = ""];
inline bool ASRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ASRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ASRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ASRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& ASRequest::cuid() const {
  return *cuid_;
}
inline void ASRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void ASRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void ASRequest::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* ASRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 client = 23 [default = 3];
inline bool ASRequest::has_client() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ASRequest::set_has_client() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ASRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ASRequest::clear_client() {
  client_ = 3;
  clear_has_client();
}
inline ::google::protobuf::int32 ASRequest::client() const {
  return client_;
}
inline void ASRequest::set_client(::google::protobuf::int32 value) {
  set_has_client();
  client_ = value;
}

// optional string s = 24 [default = "realtime_push"];
inline bool ASRequest::has_s() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ASRequest::set_has_s() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ASRequest::clear_has_s() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ASRequest::clear_s() {
  if (s_ != &_default_s_) {
    s_->assign(_default_s_);
  }
  clear_has_s();
}
inline const ::std::string& ASRequest::s() const {
  return *s_;
}
inline void ASRequest::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &_default_s_) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void ASRequest::set_s(const char* value) {
  set_has_s();
  if (s_ == &_default_s_) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void ASRequest::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &_default_s_) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_s() {
  set_has_s();
  if (s_ == &_default_s_) {
    s_ = new ::std::string(_default_s_);
  }
  return s_;
}
inline ::std::string* ASRequest::release_s() {
  clear_has_s();
  if (s_ == &_default_s_) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&_default_s_);
    return temp;
  }
}

// optional string baidu_id = 25;
inline bool ASRequest::has_baidu_id() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ASRequest::set_has_baidu_id() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ASRequest::clear_has_baidu_id() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ASRequest::clear_baidu_id() {
  if (baidu_id_ != &::google::protobuf::internal::kEmptyString) {
    baidu_id_->clear();
  }
  clear_has_baidu_id();
}
inline const ::std::string& ASRequest::baidu_id() const {
  return *baidu_id_;
}
inline void ASRequest::set_baidu_id(const ::std::string& value) {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  baidu_id_->assign(value);
}
inline void ASRequest::set_baidu_id(const char* value) {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  baidu_id_->assign(value);
}
inline void ASRequest::set_baidu_id(const char* value, size_t size) {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  baidu_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_baidu_id() {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  return baidu_id_;
}
inline ::std::string* ASRequest::release_baidu_id() {
  clear_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = baidu_id_;
    baidu_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 is_expired = 26 [default = 0];
inline bool ASRequest::has_is_expired() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ASRequest::set_has_is_expired() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ASRequest::clear_has_is_expired() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ASRequest::clear_is_expired() {
  is_expired_ = 0;
  clear_has_is_expired();
}
inline ::google::protobuf::int32 ASRequest::is_expired() const {
  return is_expired_;
}
inline void ASRequest::set_is_expired(::google::protobuf::int32 value) {
  set_has_is_expired();
  is_expired_ = value;
}

// optional string location = 27;
inline bool ASRequest::has_location() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ASRequest::set_has_location() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ASRequest::clear_has_location() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ASRequest::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& ASRequest::location() const {
  return *location_;
}
inline void ASRequest::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void ASRequest::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void ASRequest::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* ASRequest::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string keywords = 29;
inline bool ASRequest::has_keywords() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ASRequest::set_has_keywords() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ASRequest::clear_has_keywords() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ASRequest::clear_keywords() {
  if (keywords_ != &::google::protobuf::internal::kEmptyString) {
    keywords_->clear();
  }
  clear_has_keywords();
}
inline const ::std::string& ASRequest::keywords() const {
  return *keywords_;
}
inline void ASRequest::set_keywords(const ::std::string& value) {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void ASRequest::set_keywords(const char* value) {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void ASRequest::set_keywords(const char* value, size_t size) {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_keywords() {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  return keywords_;
}
inline ::std::string* ASRequest::release_keywords() {
  clear_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keywords_;
    keywords_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 is_goflush = 30 [default = 0];
inline bool ASRequest::has_is_goflush() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ASRequest::set_has_is_goflush() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ASRequest::clear_has_is_goflush() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ASRequest::clear_is_goflush() {
  is_goflush_ = 0;
  clear_has_is_goflush();
}
inline ::google::protobuf::int32 ASRequest::is_goflush() const {
  return is_goflush_;
}
inline void ASRequest::set_is_goflush(::google::protobuf::int32 value) {
  set_has_is_goflush();
  is_goflush_ = value;
}

// optional string tags = 31;
inline bool ASRequest::has_tags() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ASRequest::set_has_tags() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ASRequest::clear_has_tags() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ASRequest::clear_tags() {
  if (tags_ != &::google::protobuf::internal::kEmptyString) {
    tags_->clear();
  }
  clear_has_tags();
}
inline const ::std::string& ASRequest::tags() const {
  return *tags_;
}
inline void ASRequest::set_tags(const ::std::string& value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ASRequest::set_tags(const char* value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ASRequest::set_tags(const char* value, size_t size) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_tags() {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  return tags_;
}
inline ::std::string* ASRequest::release_tags() {
  clear_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tags_;
    tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string border = 32;
inline bool ASRequest::has_border() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ASRequest::set_has_border() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ASRequest::clear_has_border() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ASRequest::clear_border() {
  if (border_ != &::google::protobuf::internal::kEmptyString) {
    border_->clear();
  }
  clear_has_border();
}
inline const ::std::string& ASRequest::border() const {
  return *border_;
}
inline void ASRequest::set_border(const ::std::string& value) {
  set_has_border();
  if (border_ == &::google::protobuf::internal::kEmptyString) {
    border_ = new ::std::string;
  }
  border_->assign(value);
}
inline void ASRequest::set_border(const char* value) {
  set_has_border();
  if (border_ == &::google::protobuf::internal::kEmptyString) {
    border_ = new ::std::string;
  }
  border_->assign(value);
}
inline void ASRequest::set_border(const char* value, size_t size) {
  set_has_border();
  if (border_ == &::google::protobuf::internal::kEmptyString) {
    border_ = new ::std::string;
  }
  border_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_border() {
  set_has_border();
  if (border_ == &::google::protobuf::internal::kEmptyString) {
    border_ = new ::std::string;
  }
  return border_;
}
inline ::std::string* ASRequest::release_border() {
  clear_has_border();
  if (border_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = border_;
    border_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 border_start_distance = 33;
inline bool ASRequest::has_border_start_distance() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ASRequest::set_has_border_start_distance() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ASRequest::clear_has_border_start_distance() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ASRequest::clear_border_start_distance() {
  border_start_distance_ = 0;
  clear_has_border_start_distance();
}
inline ::google::protobuf::int32 ASRequest::border_start_distance() const {
  return border_start_distance_;
}
inline void ASRequest::set_border_start_distance(::google::protobuf::int32 value) {
  set_has_border_start_distance();
  border_start_distance_ = value;
}

// optional int32 border_distance = 34 [default = 500];
inline bool ASRequest::has_border_distance() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ASRequest::set_has_border_distance() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ASRequest::clear_has_border_distance() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ASRequest::clear_border_distance() {
  border_distance_ = 500;
  clear_has_border_distance();
}
inline ::google::protobuf::int32 ASRequest::border_distance() const {
  return border_distance_;
}
inline void ASRequest::set_border_distance(::google::protobuf::int32 value) {
  set_has_border_distance();
  border_distance_ = value;
}

// optional int32 verbose = 35;
inline bool ASRequest::has_verbose() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ASRequest::set_has_verbose() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ASRequest::clear_has_verbose() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ASRequest::clear_verbose() {
  verbose_ = 0;
  clear_has_verbose();
}
inline ::google::protobuf::int32 ASRequest::verbose() const {
  return verbose_;
}
inline void ASRequest::set_verbose(::google::protobuf::int32 value) {
  set_has_verbose();
  verbose_ = value;
}

// optional string coor_sys = 36 [default = "google"];
inline bool ASRequest::has_coor_sys() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ASRequest::set_has_coor_sys() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ASRequest::clear_has_coor_sys() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ASRequest::clear_coor_sys() {
  if (coor_sys_ != &_default_coor_sys_) {
    coor_sys_->assign(_default_coor_sys_);
  }
  clear_has_coor_sys();
}
inline const ::std::string& ASRequest::coor_sys() const {
  return *coor_sys_;
}
inline void ASRequest::set_coor_sys(const ::std::string& value) {
  set_has_coor_sys();
  if (coor_sys_ == &_default_coor_sys_) {
    coor_sys_ = new ::std::string;
  }
  coor_sys_->assign(value);
}
inline void ASRequest::set_coor_sys(const char* value) {
  set_has_coor_sys();
  if (coor_sys_ == &_default_coor_sys_) {
    coor_sys_ = new ::std::string;
  }
  coor_sys_->assign(value);
}
inline void ASRequest::set_coor_sys(const char* value, size_t size) {
  set_has_coor_sys();
  if (coor_sys_ == &_default_coor_sys_) {
    coor_sys_ = new ::std::string;
  }
  coor_sys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_coor_sys() {
  set_has_coor_sys();
  if (coor_sys_ == &_default_coor_sys_) {
    coor_sys_ = new ::std::string(_default_coor_sys_);
  }
  return coor_sys_;
}
inline ::std::string* ASRequest::release_coor_sys() {
  clear_has_coor_sys();
  if (coor_sys_ == &_default_coor_sys_) {
    return NULL;
  } else {
    ::std::string* temp = coor_sys_;
    coor_sys_ = const_cast< ::std::string*>(&_default_coor_sys_);
    return temp;
  }
}

// optional string nearby_id = 37;
inline bool ASRequest::has_nearby_id() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ASRequest::set_has_nearby_id() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ASRequest::clear_has_nearby_id() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ASRequest::clear_nearby_id() {
  if (nearby_id_ != &::google::protobuf::internal::kEmptyString) {
    nearby_id_->clear();
  }
  clear_has_nearby_id();
}
inline const ::std::string& ASRequest::nearby_id() const {
  return *nearby_id_;
}
inline void ASRequest::set_nearby_id(const ::std::string& value) {
  set_has_nearby_id();
  if (nearby_id_ == &::google::protobuf::internal::kEmptyString) {
    nearby_id_ = new ::std::string;
  }
  nearby_id_->assign(value);
}
inline void ASRequest::set_nearby_id(const char* value) {
  set_has_nearby_id();
  if (nearby_id_ == &::google::protobuf::internal::kEmptyString) {
    nearby_id_ = new ::std::string;
  }
  nearby_id_->assign(value);
}
inline void ASRequest::set_nearby_id(const char* value, size_t size) {
  set_has_nearby_id();
  if (nearby_id_ == &::google::protobuf::internal::kEmptyString) {
    nearby_id_ = new ::std::string;
  }
  nearby_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_nearby_id() {
  set_has_nearby_id();
  if (nearby_id_ == &::google::protobuf::internal::kEmptyString) {
    nearby_id_ = new ::std::string;
  }
  return nearby_id_;
}
inline ::std::string* ASRequest::release_nearby_id() {
  clear_has_nearby_id();
  if (nearby_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nearby_id_;
    nearby_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string str_customized_location = 38;
inline bool ASRequest::has_str_customized_location() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ASRequest::set_has_str_customized_location() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ASRequest::clear_has_str_customized_location() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ASRequest::clear_str_customized_location() {
  if (str_customized_location_ != &::google::protobuf::internal::kEmptyString) {
    str_customized_location_->clear();
  }
  clear_has_str_customized_location();
}
inline const ::std::string& ASRequest::str_customized_location() const {
  return *str_customized_location_;
}
inline void ASRequest::set_str_customized_location(const ::std::string& value) {
  set_has_str_customized_location();
  if (str_customized_location_ == &::google::protobuf::internal::kEmptyString) {
    str_customized_location_ = new ::std::string;
  }
  str_customized_location_->assign(value);
}
inline void ASRequest::set_str_customized_location(const char* value) {
  set_has_str_customized_location();
  if (str_customized_location_ == &::google::protobuf::internal::kEmptyString) {
    str_customized_location_ = new ::std::string;
  }
  str_customized_location_->assign(value);
}
inline void ASRequest::set_str_customized_location(const char* value, size_t size) {
  set_has_str_customized_location();
  if (str_customized_location_ == &::google::protobuf::internal::kEmptyString) {
    str_customized_location_ = new ::std::string;
  }
  str_customized_location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_str_customized_location() {
  set_has_str_customized_location();
  if (str_customized_location_ == &::google::protobuf::internal::kEmptyString) {
    str_customized_location_ = new ::std::string;
  }
  return str_customized_location_;
}
inline ::std::string* ASRequest::release_str_customized_location() {
  clear_has_str_customized_location();
  if (str_customized_location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_customized_location_;
    str_customized_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string userID = 39;
inline bool ASRequest::has_userid() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ASRequest::set_has_userid() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ASRequest::clear_has_userid() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ASRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& ASRequest::userid() const {
  return *userid_;
}
inline void ASRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ASRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ASRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* ASRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string need_poi = 40 [default = "1"];
inline bool ASRequest::has_need_poi() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ASRequest::set_has_need_poi() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ASRequest::clear_has_need_poi() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ASRequest::clear_need_poi() {
  if (need_poi_ != &_default_need_poi_) {
    need_poi_->assign(_default_need_poi_);
  }
  clear_has_need_poi();
}
inline const ::std::string& ASRequest::need_poi() const {
  return *need_poi_;
}
inline void ASRequest::set_need_poi(const ::std::string& value) {
  set_has_need_poi();
  if (need_poi_ == &_default_need_poi_) {
    need_poi_ = new ::std::string;
  }
  need_poi_->assign(value);
}
inline void ASRequest::set_need_poi(const char* value) {
  set_has_need_poi();
  if (need_poi_ == &_default_need_poi_) {
    need_poi_ = new ::std::string;
  }
  need_poi_->assign(value);
}
inline void ASRequest::set_need_poi(const char* value, size_t size) {
  set_has_need_poi();
  if (need_poi_ == &_default_need_poi_) {
    need_poi_ = new ::std::string;
  }
  need_poi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRequest::mutable_need_poi() {
  set_has_need_poi();
  if (need_poi_ == &_default_need_poi_) {
    need_poi_ = new ::std::string(_default_need_poi_);
  }
  return need_poi_;
}
inline ::std::string* ASRequest::release_need_poi() {
  clear_has_need_poi();
  if (need_poi_ == &_default_need_poi_) {
    return NULL;
  } else {
    ::std::string* temp = need_poi_;
    need_poi_ = const_cast< ::std::string*>(&_default_need_poi_);
    return temp;
  }
}

// -------------------------------------------------------------------

// ASFacetDetail

// optional string catg = 1;
inline bool ASFacetDetail::has_catg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASFacetDetail::set_has_catg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASFacetDetail::clear_has_catg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASFacetDetail::clear_catg() {
  if (catg_ != &::google::protobuf::internal::kEmptyString) {
    catg_->clear();
  }
  clear_has_catg();
}
inline const ::std::string& ASFacetDetail::catg() const {
  return *catg_;
}
inline void ASFacetDetail::set_catg(const ::std::string& value) {
  set_has_catg();
  if (catg_ == &::google::protobuf::internal::kEmptyString) {
    catg_ = new ::std::string;
  }
  catg_->assign(value);
}
inline void ASFacetDetail::set_catg(const char* value) {
  set_has_catg();
  if (catg_ == &::google::protobuf::internal::kEmptyString) {
    catg_ = new ::std::string;
  }
  catg_->assign(value);
}
inline void ASFacetDetail::set_catg(const char* value, size_t size) {
  set_has_catg();
  if (catg_ == &::google::protobuf::internal::kEmptyString) {
    catg_ = new ::std::string;
  }
  catg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_catg() {
  set_has_catg();
  if (catg_ == &::google::protobuf::internal::kEmptyString) {
    catg_ = new ::std::string;
  }
  return catg_;
}
inline ::std::string* ASFacetDetail::release_catg() {
  clear_has_catg();
  if (catg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catg_;
    catg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string city = 2;
inline bool ASFacetDetail::has_city() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASFacetDetail::set_has_city() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASFacetDetail::clear_has_city() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASFacetDetail::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& ASFacetDetail::city() const {
  return *city_;
}
inline void ASFacetDetail::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void ASFacetDetail::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void ASFacetDetail::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* ASFacetDetail::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string range = 3;
inline bool ASFacetDetail::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASFacetDetail::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASFacetDetail::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASFacetDetail::clear_range() {
  if (range_ != &::google::protobuf::internal::kEmptyString) {
    range_->clear();
  }
  clear_has_range();
}
inline const ::std::string& ASFacetDetail::range() const {
  return *range_;
}
inline void ASFacetDetail::set_range(const ::std::string& value) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(value);
}
inline void ASFacetDetail::set_range(const char* value) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(value);
}
inline void ASFacetDetail::set_range(const char* value, size_t size) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_range() {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  return range_;
}
inline ::std::string* ASFacetDetail::release_range() {
  clear_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = range_;
    range_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dist = 4;
inline bool ASFacetDetail::has_dist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASFacetDetail::set_has_dist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASFacetDetail::clear_has_dist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASFacetDetail::clear_dist() {
  if (dist_ != &::google::protobuf::internal::kEmptyString) {
    dist_->clear();
  }
  clear_has_dist();
}
inline const ::std::string& ASFacetDetail::dist() const {
  return *dist_;
}
inline void ASFacetDetail::set_dist(const ::std::string& value) {
  set_has_dist();
  if (dist_ == &::google::protobuf::internal::kEmptyString) {
    dist_ = new ::std::string;
  }
  dist_->assign(value);
}
inline void ASFacetDetail::set_dist(const char* value) {
  set_has_dist();
  if (dist_ == &::google::protobuf::internal::kEmptyString) {
    dist_ = new ::std::string;
  }
  dist_->assign(value);
}
inline void ASFacetDetail::set_dist(const char* value, size_t size) {
  set_has_dist();
  if (dist_ == &::google::protobuf::internal::kEmptyString) {
    dist_ = new ::std::string;
  }
  dist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_dist() {
  set_has_dist();
  if (dist_ == &::google::protobuf::internal::kEmptyString) {
    dist_ = new ::std::string;
  }
  return dist_;
}
inline ::std::string* ASFacetDetail::release_dist() {
  clear_has_dist();
  if (dist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dist_;
    dist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subcatg = 5;
inline bool ASFacetDetail::has_subcatg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ASFacetDetail::set_has_subcatg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ASFacetDetail::clear_has_subcatg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ASFacetDetail::clear_subcatg() {
  if (subcatg_ != &::google::protobuf::internal::kEmptyString) {
    subcatg_->clear();
  }
  clear_has_subcatg();
}
inline const ::std::string& ASFacetDetail::subcatg() const {
  return *subcatg_;
}
inline void ASFacetDetail::set_subcatg(const ::std::string& value) {
  set_has_subcatg();
  if (subcatg_ == &::google::protobuf::internal::kEmptyString) {
    subcatg_ = new ::std::string;
  }
  subcatg_->assign(value);
}
inline void ASFacetDetail::set_subcatg(const char* value) {
  set_has_subcatg();
  if (subcatg_ == &::google::protobuf::internal::kEmptyString) {
    subcatg_ = new ::std::string;
  }
  subcatg_->assign(value);
}
inline void ASFacetDetail::set_subcatg(const char* value, size_t size) {
  set_has_subcatg();
  if (subcatg_ == &::google::protobuf::internal::kEmptyString) {
    subcatg_ = new ::std::string;
  }
  subcatg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_subcatg() {
  set_has_subcatg();
  if (subcatg_ == &::google::protobuf::internal::kEmptyString) {
    subcatg_ = new ::std::string;
  }
  return subcatg_;
}
inline ::std::string* ASFacetDetail::release_subcatg() {
  clear_has_subcatg();
  if (subcatg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subcatg_;
    subcatg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string thirdcatg = 6;
inline bool ASFacetDetail::has_thirdcatg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ASFacetDetail::set_has_thirdcatg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ASFacetDetail::clear_has_thirdcatg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ASFacetDetail::clear_thirdcatg() {
  if (thirdcatg_ != &::google::protobuf::internal::kEmptyString) {
    thirdcatg_->clear();
  }
  clear_has_thirdcatg();
}
inline const ::std::string& ASFacetDetail::thirdcatg() const {
  return *thirdcatg_;
}
inline void ASFacetDetail::set_thirdcatg(const ::std::string& value) {
  set_has_thirdcatg();
  if (thirdcatg_ == &::google::protobuf::internal::kEmptyString) {
    thirdcatg_ = new ::std::string;
  }
  thirdcatg_->assign(value);
}
inline void ASFacetDetail::set_thirdcatg(const char* value) {
  set_has_thirdcatg();
  if (thirdcatg_ == &::google::protobuf::internal::kEmptyString) {
    thirdcatg_ = new ::std::string;
  }
  thirdcatg_->assign(value);
}
inline void ASFacetDetail::set_thirdcatg(const char* value, size_t size) {
  set_has_thirdcatg();
  if (thirdcatg_ == &::google::protobuf::internal::kEmptyString) {
    thirdcatg_ = new ::std::string;
  }
  thirdcatg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_thirdcatg() {
  set_has_thirdcatg();
  if (thirdcatg_ == &::google::protobuf::internal::kEmptyString) {
    thirdcatg_ = new ::std::string;
  }
  return thirdcatg_;
}
inline ::std::string* ASFacetDetail::release_thirdcatg() {
  clear_has_thirdcatg();
  if (thirdcatg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirdcatg_;
    thirdcatg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tags = 7;
inline bool ASFacetDetail::has_tags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ASFacetDetail::set_has_tags() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ASFacetDetail::clear_has_tags() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ASFacetDetail::clear_tags() {
  if (tags_ != &::google::protobuf::internal::kEmptyString) {
    tags_->clear();
  }
  clear_has_tags();
}
inline const ::std::string& ASFacetDetail::tags() const {
  return *tags_;
}
inline void ASFacetDetail::set_tags(const ::std::string& value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ASFacetDetail::set_tags(const char* value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ASFacetDetail::set_tags(const char* value, size_t size) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_tags() {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  return tags_;
}
inline ::std::string* ASFacetDetail::release_tags() {
  clear_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tags_;
    tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subway_line = 8;
inline bool ASFacetDetail::has_subway_line() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ASFacetDetail::set_has_subway_line() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ASFacetDetail::clear_has_subway_line() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ASFacetDetail::clear_subway_line() {
  if (subway_line_ != &::google::protobuf::internal::kEmptyString) {
    subway_line_->clear();
  }
  clear_has_subway_line();
}
inline const ::std::string& ASFacetDetail::subway_line() const {
  return *subway_line_;
}
inline void ASFacetDetail::set_subway_line(const ::std::string& value) {
  set_has_subway_line();
  if (subway_line_ == &::google::protobuf::internal::kEmptyString) {
    subway_line_ = new ::std::string;
  }
  subway_line_->assign(value);
}
inline void ASFacetDetail::set_subway_line(const char* value) {
  set_has_subway_line();
  if (subway_line_ == &::google::protobuf::internal::kEmptyString) {
    subway_line_ = new ::std::string;
  }
  subway_line_->assign(value);
}
inline void ASFacetDetail::set_subway_line(const char* value, size_t size) {
  set_has_subway_line();
  if (subway_line_ == &::google::protobuf::internal::kEmptyString) {
    subway_line_ = new ::std::string;
  }
  subway_line_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_subway_line() {
  set_has_subway_line();
  if (subway_line_ == &::google::protobuf::internal::kEmptyString) {
    subway_line_ = new ::std::string;
  }
  return subway_line_;
}
inline ::std::string* ASFacetDetail::release_subway_line() {
  clear_has_subway_line();
  if (subway_line_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subway_line_;
    subway_line_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subway_station = 9;
inline bool ASFacetDetail::has_subway_station() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ASFacetDetail::set_has_subway_station() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ASFacetDetail::clear_has_subway_station() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ASFacetDetail::clear_subway_station() {
  if (subway_station_ != &::google::protobuf::internal::kEmptyString) {
    subway_station_->clear();
  }
  clear_has_subway_station();
}
inline const ::std::string& ASFacetDetail::subway_station() const {
  return *subway_station_;
}
inline void ASFacetDetail::set_subway_station(const ::std::string& value) {
  set_has_subway_station();
  if (subway_station_ == &::google::protobuf::internal::kEmptyString) {
    subway_station_ = new ::std::string;
  }
  subway_station_->assign(value);
}
inline void ASFacetDetail::set_subway_station(const char* value) {
  set_has_subway_station();
  if (subway_station_ == &::google::protobuf::internal::kEmptyString) {
    subway_station_ = new ::std::string;
  }
  subway_station_->assign(value);
}
inline void ASFacetDetail::set_subway_station(const char* value, size_t size) {
  set_has_subway_station();
  if (subway_station_ == &::google::protobuf::internal::kEmptyString) {
    subway_station_ = new ::std::string;
  }
  subway_station_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASFacetDetail::mutable_subway_station() {
  set_has_subway_station();
  if (subway_station_ == &::google::protobuf::internal::kEmptyString) {
    subway_station_ = new ::std::string;
  }
  return subway_station_;
}
inline ::std::string* ASFacetDetail::release_subway_station() {
  clear_has_subway_station();
  if (subway_station_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subway_station_;
    subway_station_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ASPoiDetail

// optional int32 poiid = 1;
inline bool ASPoiDetail::has_poiid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASPoiDetail::set_has_poiid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASPoiDetail::clear_has_poiid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASPoiDetail::clear_poiid() {
  poiid_ = 0;
  clear_has_poiid();
}
inline ::google::protobuf::int32 ASPoiDetail::poiid() const {
  return poiid_;
}
inline void ASPoiDetail::set_poiid(::google::protobuf::int32 value) {
  set_has_poiid();
  poiid_ = value;
}

// optional int32 x = 2;
inline bool ASPoiDetail::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASPoiDetail::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASPoiDetail::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASPoiDetail::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 ASPoiDetail::x() const {
  return x_;
}
inline void ASPoiDetail::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool ASPoiDetail::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASPoiDetail::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASPoiDetail::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASPoiDetail::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 ASPoiDetail::y() const {
  return y_;
}
inline void ASPoiDetail::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 distance = 4;
inline bool ASPoiDetail::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASPoiDetail::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASPoiDetail::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASPoiDetail::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline ::google::protobuf::int32 ASPoiDetail::distance() const {
  return distance_;
}
inline void ASPoiDetail::set_distance(::google::protobuf::int32 value) {
  set_has_distance();
  distance_ = value;
}

// -------------------------------------------------------------------

// ASDistInfo

// optional int32 id = 1;
inline bool ASDistInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASDistInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASDistInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASDistInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ASDistInfo::id() const {
  return id_;
}
inline void ASDistInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool ASDistInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASDistInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASDistInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASDistInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ASDistInfo::name() const {
  return *name_;
}
inline void ASDistInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ASDistInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ASDistInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDistInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ASDistInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ASDealDetail

// optional int32 id = 1;
inline bool ASDealDetail::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASDealDetail::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASDealDetail::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASDealDetail::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ASDealDetail::id() const {
  return id_;
}
inline void ASDealDetail::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string image = 2;
inline bool ASDealDetail::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASDealDetail::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASDealDetail::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASDealDetail::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& ASDealDetail::image() const {
  return *image_;
}
inline void ASDealDetail::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ASDealDetail::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ASDealDetail::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* ASDealDetail::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string mid_image = 3;
inline bool ASDealDetail::has_mid_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASDealDetail::set_has_mid_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASDealDetail::clear_has_mid_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASDealDetail::clear_mid_image() {
  if (mid_image_ != &::google::protobuf::internal::kEmptyString) {
    mid_image_->clear();
  }
  clear_has_mid_image();
}
inline const ::std::string& ASDealDetail::mid_image() const {
  return *mid_image_;
}
inline void ASDealDetail::set_mid_image(const ::std::string& value) {
  set_has_mid_image();
  if (mid_image_ == &::google::protobuf::internal::kEmptyString) {
    mid_image_ = new ::std::string;
  }
  mid_image_->assign(value);
}
inline void ASDealDetail::set_mid_image(const char* value) {
  set_has_mid_image();
  if (mid_image_ == &::google::protobuf::internal::kEmptyString) {
    mid_image_ = new ::std::string;
  }
  mid_image_->assign(value);
}
inline void ASDealDetail::set_mid_image(const char* value, size_t size) {
  set_has_mid_image();
  if (mid_image_ == &::google::protobuf::internal::kEmptyString) {
    mid_image_ = new ::std::string;
  }
  mid_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_mid_image() {
  set_has_mid_image();
  if (mid_image_ == &::google::protobuf::internal::kEmptyString) {
    mid_image_ = new ::std::string;
  }
  return mid_image_;
}
inline ::std::string* ASDealDetail::release_mid_image() {
  clear_has_mid_image();
  if (mid_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mid_image_;
    mid_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tiny_image = 4;
inline bool ASDealDetail::has_tiny_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASDealDetail::set_has_tiny_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASDealDetail::clear_has_tiny_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASDealDetail::clear_tiny_image() {
  if (tiny_image_ != &::google::protobuf::internal::kEmptyString) {
    tiny_image_->clear();
  }
  clear_has_tiny_image();
}
inline const ::std::string& ASDealDetail::tiny_image() const {
  return *tiny_image_;
}
inline void ASDealDetail::set_tiny_image(const ::std::string& value) {
  set_has_tiny_image();
  if (tiny_image_ == &::google::protobuf::internal::kEmptyString) {
    tiny_image_ = new ::std::string;
  }
  tiny_image_->assign(value);
}
inline void ASDealDetail::set_tiny_image(const char* value) {
  set_has_tiny_image();
  if (tiny_image_ == &::google::protobuf::internal::kEmptyString) {
    tiny_image_ = new ::std::string;
  }
  tiny_image_->assign(value);
}
inline void ASDealDetail::set_tiny_image(const char* value, size_t size) {
  set_has_tiny_image();
  if (tiny_image_ == &::google::protobuf::internal::kEmptyString) {
    tiny_image_ = new ::std::string;
  }
  tiny_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_tiny_image() {
  set_has_tiny_image();
  if (tiny_image_ == &::google::protobuf::internal::kEmptyString) {
    tiny_image_ = new ::std::string;
  }
  return tiny_image_;
}
inline ::std::string* ASDealDetail::release_tiny_image() {
  clear_has_tiny_image();
  if (tiny_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tiny_image_;
    tiny_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string business_title = 5;
inline bool ASDealDetail::has_business_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ASDealDetail::set_has_business_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ASDealDetail::clear_has_business_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ASDealDetail::clear_business_title() {
  if (business_title_ != &::google::protobuf::internal::kEmptyString) {
    business_title_->clear();
  }
  clear_has_business_title();
}
inline const ::std::string& ASDealDetail::business_title() const {
  return *business_title_;
}
inline void ASDealDetail::set_business_title(const ::std::string& value) {
  set_has_business_title();
  if (business_title_ == &::google::protobuf::internal::kEmptyString) {
    business_title_ = new ::std::string;
  }
  business_title_->assign(value);
}
inline void ASDealDetail::set_business_title(const char* value) {
  set_has_business_title();
  if (business_title_ == &::google::protobuf::internal::kEmptyString) {
    business_title_ = new ::std::string;
  }
  business_title_->assign(value);
}
inline void ASDealDetail::set_business_title(const char* value, size_t size) {
  set_has_business_title();
  if (business_title_ == &::google::protobuf::internal::kEmptyString) {
    business_title_ = new ::std::string;
  }
  business_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_business_title() {
  set_has_business_title();
  if (business_title_ == &::google::protobuf::internal::kEmptyString) {
    business_title_ = new ::std::string;
  }
  return business_title_;
}
inline ::std::string* ASDealDetail::release_business_title() {
  clear_has_business_title();
  if (business_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = business_title_;
    business_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string medium_title = 6;
inline bool ASDealDetail::has_medium_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ASDealDetail::set_has_medium_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ASDealDetail::clear_has_medium_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ASDealDetail::clear_medium_title() {
  if (medium_title_ != &::google::protobuf::internal::kEmptyString) {
    medium_title_->clear();
  }
  clear_has_medium_title();
}
inline const ::std::string& ASDealDetail::medium_title() const {
  return *medium_title_;
}
inline void ASDealDetail::set_medium_title(const ::std::string& value) {
  set_has_medium_title();
  if (medium_title_ == &::google::protobuf::internal::kEmptyString) {
    medium_title_ = new ::std::string;
  }
  medium_title_->assign(value);
}
inline void ASDealDetail::set_medium_title(const char* value) {
  set_has_medium_title();
  if (medium_title_ == &::google::protobuf::internal::kEmptyString) {
    medium_title_ = new ::std::string;
  }
  medium_title_->assign(value);
}
inline void ASDealDetail::set_medium_title(const char* value, size_t size) {
  set_has_medium_title();
  if (medium_title_ == &::google::protobuf::internal::kEmptyString) {
    medium_title_ = new ::std::string;
  }
  medium_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_medium_title() {
  set_has_medium_title();
  if (medium_title_ == &::google::protobuf::internal::kEmptyString) {
    medium_title_ = new ::std::string;
  }
  return medium_title_;
}
inline ::std::string* ASDealDetail::release_medium_title() {
  clear_has_medium_title();
  if (medium_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = medium_title_;
    medium_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string title_high_price = 7;
inline bool ASDealDetail::has_title_high_price() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ASDealDetail::set_has_title_high_price() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ASDealDetail::clear_has_title_high_price() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ASDealDetail::clear_title_high_price() {
  if (title_high_price_ != &::google::protobuf::internal::kEmptyString) {
    title_high_price_->clear();
  }
  clear_has_title_high_price();
}
inline const ::std::string& ASDealDetail::title_high_price() const {
  return *title_high_price_;
}
inline void ASDealDetail::set_title_high_price(const ::std::string& value) {
  set_has_title_high_price();
  if (title_high_price_ == &::google::protobuf::internal::kEmptyString) {
    title_high_price_ = new ::std::string;
  }
  title_high_price_->assign(value);
}
inline void ASDealDetail::set_title_high_price(const char* value) {
  set_has_title_high_price();
  if (title_high_price_ == &::google::protobuf::internal::kEmptyString) {
    title_high_price_ = new ::std::string;
  }
  title_high_price_->assign(value);
}
inline void ASDealDetail::set_title_high_price(const char* value, size_t size) {
  set_has_title_high_price();
  if (title_high_price_ == &::google::protobuf::internal::kEmptyString) {
    title_high_price_ = new ::std::string;
  }
  title_high_price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_title_high_price() {
  set_has_title_high_price();
  if (title_high_price_ == &::google::protobuf::internal::kEmptyString) {
    title_high_price_ = new ::std::string;
  }
  return title_high_price_;
}
inline ::std::string* ASDealDetail::release_title_high_price() {
  clear_has_title_high_price();
  if (title_high_price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_high_price_;
    title_high_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string min_title = 8;
inline bool ASDealDetail::has_min_title() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ASDealDetail::set_has_min_title() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ASDealDetail::clear_has_min_title() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ASDealDetail::clear_min_title() {
  if (min_title_ != &::google::protobuf::internal::kEmptyString) {
    min_title_->clear();
  }
  clear_has_min_title();
}
inline const ::std::string& ASDealDetail::min_title() const {
  return *min_title_;
}
inline void ASDealDetail::set_min_title(const ::std::string& value) {
  set_has_min_title();
  if (min_title_ == &::google::protobuf::internal::kEmptyString) {
    min_title_ = new ::std::string;
  }
  min_title_->assign(value);
}
inline void ASDealDetail::set_min_title(const char* value) {
  set_has_min_title();
  if (min_title_ == &::google::protobuf::internal::kEmptyString) {
    min_title_ = new ::std::string;
  }
  min_title_->assign(value);
}
inline void ASDealDetail::set_min_title(const char* value, size_t size) {
  set_has_min_title();
  if (min_title_ == &::google::protobuf::internal::kEmptyString) {
    min_title_ = new ::std::string;
  }
  min_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_min_title() {
  set_has_min_title();
  if (min_title_ == &::google::protobuf::internal::kEmptyString) {
    min_title_ = new ::std::string;
  }
  return min_title_;
}
inline ::std::string* ASDealDetail::release_min_title() {
  clear_has_min_title();
  if (min_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = min_title_;
    min_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 price_ori = 9;
inline bool ASDealDetail::has_price_ori() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ASDealDetail::set_has_price_ori() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ASDealDetail::clear_has_price_ori() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ASDealDetail::clear_price_ori() {
  price_ori_ = 0;
  clear_has_price_ori();
}
inline ::google::protobuf::int32 ASDealDetail::price_ori() const {
  return price_ori_;
}
inline void ASDealDetail::set_price_ori(::google::protobuf::int32 value) {
  set_has_price_ori();
  price_ori_ = value;
}

// optional int32 price_current = 10;
inline bool ASDealDetail::has_price_current() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ASDealDetail::set_has_price_current() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ASDealDetail::clear_has_price_current() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ASDealDetail::clear_price_current() {
  price_current_ = 0;
  clear_has_price_current();
}
inline ::google::protobuf::int32 ASDealDetail::price_current() const {
  return price_current_;
}
inline void ASDealDetail::set_price_current(::google::protobuf::int32 value) {
  set_has_price_current();
  price_current_ = value;
}

// optional string tags = 11;
inline bool ASDealDetail::has_tags() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ASDealDetail::set_has_tags() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ASDealDetail::clear_has_tags() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ASDealDetail::clear_tags() {
  if (tags_ != &::google::protobuf::internal::kEmptyString) {
    tags_->clear();
  }
  clear_has_tags();
}
inline const ::std::string& ASDealDetail::tags() const {
  return *tags_;
}
inline void ASDealDetail::set_tags(const ::std::string& value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ASDealDetail::set_tags(const char* value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ASDealDetail::set_tags(const char* value, size_t size) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_tags() {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  return tags_;
}
inline ::std::string* ASDealDetail::release_tags() {
  clear_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tags_;
    tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 is_new = 12;
inline bool ASDealDetail::has_is_new() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ASDealDetail::set_has_is_new() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ASDealDetail::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ASDealDetail::clear_is_new() {
  is_new_ = 0;
  clear_has_is_new();
}
inline ::google::protobuf::int32 ASDealDetail::is_new() const {
  return is_new_;
}
inline void ASDealDetail::set_is_new(::google::protobuf::int32 value) {
  set_has_is_new();
  is_new_ = value;
}

// optional int32 sale_count = 13;
inline bool ASDealDetail::has_sale_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ASDealDetail::set_has_sale_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ASDealDetail::clear_has_sale_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ASDealDetail::clear_sale_count() {
  sale_count_ = 0;
  clear_has_sale_count();
}
inline ::google::protobuf::int32 ASDealDetail::sale_count() const {
  return sale_count_;
}
inline void ASDealDetail::set_sale_count(::google::protobuf::int32 value) {
  set_has_sale_count();
  sale_count_ = value;
}

// optional int32 type = 14;
inline bool ASDealDetail::has_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ASDealDetail::set_has_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ASDealDetail::clear_has_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ASDealDetail::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ASDealDetail::type() const {
  return type_;
}
inline void ASDealDetail::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 pay_start_time = 15;
inline bool ASDealDetail::has_pay_start_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ASDealDetail::set_has_pay_start_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ASDealDetail::clear_has_pay_start_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ASDealDetail::clear_pay_start_time() {
  pay_start_time_ = 0;
  clear_has_pay_start_time();
}
inline ::google::protobuf::int32 ASDealDetail::pay_start_time() const {
  return pay_start_time_;
}
inline void ASDealDetail::set_pay_start_time(::google::protobuf::int32 value) {
  set_has_pay_start_time();
  pay_start_time_ = value;
}

// optional int32 pay_end_time = 16;
inline bool ASDealDetail::has_pay_end_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ASDealDetail::set_has_pay_end_time() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ASDealDetail::clear_has_pay_end_time() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ASDealDetail::clear_pay_end_time() {
  pay_end_time_ = 0;
  clear_has_pay_end_time();
}
inline ::google::protobuf::int32 ASDealDetail::pay_end_time() const {
  return pay_end_time_;
}
inline void ASDealDetail::set_pay_end_time(::google::protobuf::int32 value) {
  set_has_pay_end_time();
  pay_end_time_ = value;
}

// optional int32 deal_start_time = 17;
inline bool ASDealDetail::has_deal_start_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ASDealDetail::set_has_deal_start_time() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ASDealDetail::clear_has_deal_start_time() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ASDealDetail::clear_deal_start_time() {
  deal_start_time_ = 0;
  clear_has_deal_start_time();
}
inline ::google::protobuf::int32 ASDealDetail::deal_start_time() const {
  return deal_start_time_;
}
inline void ASDealDetail::set_deal_start_time(::google::protobuf::int32 value) {
  set_has_deal_start_time();
  deal_start_time_ = value;
}

// optional int32 deal_expire_time = 18;
inline bool ASDealDetail::has_deal_expire_time() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ASDealDetail::set_has_deal_expire_time() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ASDealDetail::clear_has_deal_expire_time() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ASDealDetail::clear_deal_expire_time() {
  deal_expire_time_ = 0;
  clear_has_deal_expire_time();
}
inline ::google::protobuf::int32 ASDealDetail::deal_expire_time() const {
  return deal_expire_time_;
}
inline void ASDealDetail::set_deal_expire_time(::google::protobuf::int32 value) {
  set_has_deal_expire_time();
  deal_expire_time_ = value;
}

// optional int32 city_num = 19;
inline bool ASDealDetail::has_city_num() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ASDealDetail::set_has_city_num() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ASDealDetail::clear_has_city_num() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ASDealDetail::clear_city_num() {
  city_num_ = 0;
  clear_has_city_num();
}
inline ::google::protobuf::int32 ASDealDetail::city_num() const {
  return city_num_;
}
inline void ASDealDetail::set_city_num(::google::protobuf::int32 value) {
  set_has_city_num();
  city_num_ = value;
}

// optional int32 poi_num = 20;
inline bool ASDealDetail::has_poi_num() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ASDealDetail::set_has_poi_num() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ASDealDetail::clear_has_poi_num() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ASDealDetail::clear_poi_num() {
  poi_num_ = 0;
  clear_has_poi_num();
}
inline ::google::protobuf::int32 ASDealDetail::poi_num() const {
  return poi_num_;
}
inline void ASDealDetail::set_poi_num(::google::protobuf::int32 value) {
  set_has_poi_num();
  poi_num_ = value;
}

// repeated .lbs.da.openservice.ASPoiDetail poi = 21;
inline int ASDealDetail::poi_size() const {
  return poi_.size();
}
inline void ASDealDetail::clear_poi() {
  poi_.Clear();
}
inline const ::lbs::da::openservice::ASPoiDetail& ASDealDetail::poi(int index) const {
  return poi_.Get(index);
}
inline ::lbs::da::openservice::ASPoiDetail* ASDealDetail::mutable_poi(int index) {
  return poi_.Mutable(index);
}
inline ::lbs::da::openservice::ASPoiDetail* ASDealDetail::add_poi() {
  return poi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASPoiDetail >&
ASDealDetail::poi() const {
  return poi_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASPoiDetail >*
ASDealDetail::mutable_poi() {
  return &poi_;
}

// optional string range = 22;
inline bool ASDealDetail::has_range() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ASDealDetail::set_has_range() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ASDealDetail::clear_has_range() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ASDealDetail::clear_range() {
  if (range_ != &::google::protobuf::internal::kEmptyString) {
    range_->clear();
  }
  clear_has_range();
}
inline const ::std::string& ASDealDetail::range() const {
  return *range_;
}
inline void ASDealDetail::set_range(const ::std::string& value) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(value);
}
inline void ASDealDetail::set_range(const char* value) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(value);
}
inline void ASDealDetail::set_range(const char* value, size_t size) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_range() {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  return range_;
}
inline ::std::string* ASDealDetail::release_range() {
  clear_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = range_;
    range_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 score = 23;
inline bool ASDealDetail::has_score() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ASDealDetail::set_has_score() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ASDealDetail::clear_has_score() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ASDealDetail::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ASDealDetail::score() const {
  return score_;
}
inline void ASDealDetail::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 comment_num = 24;
inline bool ASDealDetail::has_comment_num() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ASDealDetail::set_has_comment_num() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ASDealDetail::clear_has_comment_num() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ASDealDetail::clear_comment_num() {
  comment_num_ = 0;
  clear_has_comment_num();
}
inline ::google::protobuf::int32 ASDealDetail::comment_num() const {
  return comment_num_;
}
inline void ASDealDetail::set_comment_num(::google::protobuf::int32 value) {
  set_has_comment_num();
  comment_num_ = value;
}

// optional int32 bought_weekly = 25;
inline bool ASDealDetail::has_bought_weekly() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ASDealDetail::set_has_bought_weekly() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ASDealDetail::clear_has_bought_weekly() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ASDealDetail::clear_bought_weekly() {
  bought_weekly_ = 0;
  clear_has_bought_weekly();
}
inline ::google::protobuf::int32 ASDealDetail::bought_weekly() const {
  return bought_weekly_;
}
inline void ASDealDetail::set_bought_weekly(::google::protobuf::int32 value) {
  set_has_bought_weekly();
  bought_weekly_ = value;
}

// optional string tiny_url = 26;
inline bool ASDealDetail::has_tiny_url() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ASDealDetail::set_has_tiny_url() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ASDealDetail::clear_has_tiny_url() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ASDealDetail::clear_tiny_url() {
  if (tiny_url_ != &::google::protobuf::internal::kEmptyString) {
    tiny_url_->clear();
  }
  clear_has_tiny_url();
}
inline const ::std::string& ASDealDetail::tiny_url() const {
  return *tiny_url_;
}
inline void ASDealDetail::set_tiny_url(const ::std::string& value) {
  set_has_tiny_url();
  if (tiny_url_ == &::google::protobuf::internal::kEmptyString) {
    tiny_url_ = new ::std::string;
  }
  tiny_url_->assign(value);
}
inline void ASDealDetail::set_tiny_url(const char* value) {
  set_has_tiny_url();
  if (tiny_url_ == &::google::protobuf::internal::kEmptyString) {
    tiny_url_ = new ::std::string;
  }
  tiny_url_->assign(value);
}
inline void ASDealDetail::set_tiny_url(const char* value, size_t size) {
  set_has_tiny_url();
  if (tiny_url_ == &::google::protobuf::internal::kEmptyString) {
    tiny_url_ = new ::std::string;
  }
  tiny_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASDealDetail::mutable_tiny_url() {
  set_has_tiny_url();
  if (tiny_url_ == &::google::protobuf::internal::kEmptyString) {
    tiny_url_ = new ::std::string;
  }
  return tiny_url_;
}
inline ::std::string* ASDealDetail::release_tiny_url() {
  clear_has_tiny_url();
  if (tiny_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tiny_url_;
    tiny_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .lbs.da.openservice.ASDistInfo dist_info = 27;
inline bool ASDealDetail::has_dist_info() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ASDealDetail::set_has_dist_info() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ASDealDetail::clear_has_dist_info() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ASDealDetail::clear_dist_info() {
  if (dist_info_ != NULL) dist_info_->::lbs::da::openservice::ASDistInfo::Clear();
  clear_has_dist_info();
}
inline const ::lbs::da::openservice::ASDistInfo& ASDealDetail::dist_info() const {
  return dist_info_ != NULL ? *dist_info_ : *default_instance_->dist_info_;
}
inline ::lbs::da::openservice::ASDistInfo* ASDealDetail::mutable_dist_info() {
  set_has_dist_info();
  if (dist_info_ == NULL) dist_info_ = new ::lbs::da::openservice::ASDistInfo;
  return dist_info_;
}
inline ::lbs::da::openservice::ASDistInfo* ASDealDetail::release_dist_info() {
  clear_has_dist_info();
  ::lbs::da::openservice::ASDistInfo* temp = dist_info_;
  dist_info_ = NULL;
  return temp;
}

// optional int32 is_national = 28;
inline bool ASDealDetail::has_is_national() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ASDealDetail::set_has_is_national() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ASDealDetail::clear_has_is_national() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ASDealDetail::clear_is_national() {
  is_national_ = 0;
  clear_has_is_national();
}
inline ::google::protobuf::int32 ASDealDetail::is_national() const {
  return is_national_;
}
inline void ASDealDetail::set_is_national(::google::protobuf::int32 value) {
  set_has_is_national();
  is_national_ = value;
}

// optional int32 num_brother = 29;
inline bool ASDealDetail::has_num_brother() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ASDealDetail::set_has_num_brother() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ASDealDetail::clear_has_num_brother() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ASDealDetail::clear_num_brother() {
  num_brother_ = 0;
  clear_has_num_brother();
}
inline ::google::protobuf::int32 ASDealDetail::num_brother() const {
  return num_brother_;
}
inline void ASDealDetail::set_num_brother(::google::protobuf::int32 value) {
  set_has_num_brother();
  num_brother_ = value;
}

// -------------------------------------------------------------------

// ASResponse

// optional string data = 1;
inline bool ASResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ASResponse::data() const {
  return *data_;
}
inline void ASResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ASResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ASResponse::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ASResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string head_data = 2;
inline bool ASResponse::has_head_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASResponse::set_has_head_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASResponse::clear_has_head_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASResponse::clear_head_data() {
  if (head_data_ != &::google::protobuf::internal::kEmptyString) {
    head_data_->clear();
  }
  clear_has_head_data();
}
inline const ::std::string& ASResponse::head_data() const {
  return *head_data_;
}
inline void ASResponse::set_head_data(const ::std::string& value) {
  set_has_head_data();
  if (head_data_ == &::google::protobuf::internal::kEmptyString) {
    head_data_ = new ::std::string;
  }
  head_data_->assign(value);
}
inline void ASResponse::set_head_data(const char* value) {
  set_has_head_data();
  if (head_data_ == &::google::protobuf::internal::kEmptyString) {
    head_data_ = new ::std::string;
  }
  head_data_->assign(value);
}
inline void ASResponse::set_head_data(const char* value, size_t size) {
  set_has_head_data();
  if (head_data_ == &::google::protobuf::internal::kEmptyString) {
    head_data_ = new ::std::string;
  }
  head_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASResponse::mutable_head_data() {
  set_has_head_data();
  if (head_data_ == &::google::protobuf::internal::kEmptyString) {
    head_data_ = new ::std::string;
  }
  return head_data_;
}
inline ::std::string* ASResponse::release_head_data() {
  clear_has_head_data();
  if (head_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_data_;
    head_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .lbs.da.openservice.ASFacetDetail facet = 3;
inline bool ASResponse::has_facet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASResponse::set_has_facet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASResponse::clear_has_facet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASResponse::clear_facet() {
  if (facet_ != NULL) facet_->::lbs::da::openservice::ASFacetDetail::Clear();
  clear_has_facet();
}
inline const ::lbs::da::openservice::ASFacetDetail& ASResponse::facet() const {
  return facet_ != NULL ? *facet_ : *default_instance_->facet_;
}
inline ::lbs::da::openservice::ASFacetDetail* ASResponse::mutable_facet() {
  set_has_facet();
  if (facet_ == NULL) facet_ = new ::lbs::da::openservice::ASFacetDetail;
  return facet_;
}
inline ::lbs::da::openservice::ASFacetDetail* ASResponse::release_facet() {
  clear_has_facet();
  ::lbs::da::openservice::ASFacetDetail* temp = facet_;
  facet_ = NULL;
  return temp;
}

// optional int32 total = 4;
inline bool ASResponse::has_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASResponse::set_has_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASResponse::clear_has_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASResponse::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 ASResponse::total() const {
  return total_;
}
inline void ASResponse::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// optional string remain = 5;
inline bool ASResponse::has_remain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ASResponse::set_has_remain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ASResponse::clear_has_remain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ASResponse::clear_remain() {
  if (remain_ != &::google::protobuf::internal::kEmptyString) {
    remain_->clear();
  }
  clear_has_remain();
}
inline const ::std::string& ASResponse::remain() const {
  return *remain_;
}
inline void ASResponse::set_remain(const ::std::string& value) {
  set_has_remain();
  if (remain_ == &::google::protobuf::internal::kEmptyString) {
    remain_ = new ::std::string;
  }
  remain_->assign(value);
}
inline void ASResponse::set_remain(const char* value) {
  set_has_remain();
  if (remain_ == &::google::protobuf::internal::kEmptyString) {
    remain_ = new ::std::string;
  }
  remain_->assign(value);
}
inline void ASResponse::set_remain(const char* value, size_t size) {
  set_has_remain();
  if (remain_ == &::google::protobuf::internal::kEmptyString) {
    remain_ = new ::std::string;
  }
  remain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASResponse::mutable_remain() {
  set_has_remain();
  if (remain_ == &::google::protobuf::internal::kEmptyString) {
    remain_ = new ::std::string;
  }
  return remain_;
}
inline ::std::string* ASResponse::release_remain() {
  clear_has_remain();
  if (remain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remain_;
    remain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string landmark_distance = 6;
inline bool ASResponse::has_landmark_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ASResponse::set_has_landmark_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ASResponse::clear_has_landmark_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ASResponse::clear_landmark_distance() {
  if (landmark_distance_ != &::google::protobuf::internal::kEmptyString) {
    landmark_distance_->clear();
  }
  clear_has_landmark_distance();
}
inline const ::std::string& ASResponse::landmark_distance() const {
  return *landmark_distance_;
}
inline void ASResponse::set_landmark_distance(const ::std::string& value) {
  set_has_landmark_distance();
  if (landmark_distance_ == &::google::protobuf::internal::kEmptyString) {
    landmark_distance_ = new ::std::string;
  }
  landmark_distance_->assign(value);
}
inline void ASResponse::set_landmark_distance(const char* value) {
  set_has_landmark_distance();
  if (landmark_distance_ == &::google::protobuf::internal::kEmptyString) {
    landmark_distance_ = new ::std::string;
  }
  landmark_distance_->assign(value);
}
inline void ASResponse::set_landmark_distance(const char* value, size_t size) {
  set_has_landmark_distance();
  if (landmark_distance_ == &::google::protobuf::internal::kEmptyString) {
    landmark_distance_ = new ::std::string;
  }
  landmark_distance_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASResponse::mutable_landmark_distance() {
  set_has_landmark_distance();
  if (landmark_distance_ == &::google::protobuf::internal::kEmptyString) {
    landmark_distance_ = new ::std::string;
  }
  return landmark_distance_;
}
inline ::std::string* ASResponse::release_landmark_distance() {
  clear_has_landmark_distance();
  if (landmark_distance_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = landmark_distance_;
    landmark_distance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nearby_distance = 7;
inline bool ASResponse::has_nearby_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ASResponse::set_has_nearby_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ASResponse::clear_has_nearby_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ASResponse::clear_nearby_distance() {
  if (nearby_distance_ != &::google::protobuf::internal::kEmptyString) {
    nearby_distance_->clear();
  }
  clear_has_nearby_distance();
}
inline const ::std::string& ASResponse::nearby_distance() const {
  return *nearby_distance_;
}
inline void ASResponse::set_nearby_distance(const ::std::string& value) {
  set_has_nearby_distance();
  if (nearby_distance_ == &::google::protobuf::internal::kEmptyString) {
    nearby_distance_ = new ::std::string;
  }
  nearby_distance_->assign(value);
}
inline void ASResponse::set_nearby_distance(const char* value) {
  set_has_nearby_distance();
  if (nearby_distance_ == &::google::protobuf::internal::kEmptyString) {
    nearby_distance_ = new ::std::string;
  }
  nearby_distance_->assign(value);
}
inline void ASResponse::set_nearby_distance(const char* value, size_t size) {
  set_has_nearby_distance();
  if (nearby_distance_ == &::google::protobuf::internal::kEmptyString) {
    nearby_distance_ = new ::std::string;
  }
  nearby_distance_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASResponse::mutable_nearby_distance() {
  set_has_nearby_distance();
  if (nearby_distance_ == &::google::protobuf::internal::kEmptyString) {
    nearby_distance_ = new ::std::string;
  }
  return nearby_distance_;
}
inline ::std::string* ASResponse::release_nearby_distance() {
  clear_has_nearby_distance();
  if (nearby_distance_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nearby_distance_;
    nearby_distance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 query_dist = 8;
inline bool ASResponse::has_query_dist() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ASResponse::set_has_query_dist() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ASResponse::clear_has_query_dist() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ASResponse::clear_query_dist() {
  query_dist_ = 0;
  clear_has_query_dist();
}
inline ::google::protobuf::int32 ASResponse::query_dist() const {
  return query_dist_;
}
inline void ASResponse::set_query_dist(::google::protobuf::int32 value) {
  set_has_query_dist();
  query_dist_ = value;
}

// optional int32 query_range = 9;
inline bool ASResponse::has_query_range() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ASResponse::set_has_query_range() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ASResponse::clear_has_query_range() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ASResponse::clear_query_range() {
  query_range_ = 0;
  clear_has_query_range();
}
inline ::google::protobuf::int32 ASResponse::query_range() const {
  return query_range_;
}
inline void ASResponse::set_query_range(::google::protobuf::int32 value) {
  set_has_query_range();
  query_range_ = value;
}

// optional string highlights = 10;
inline bool ASResponse::has_highlights() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ASResponse::set_has_highlights() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ASResponse::clear_has_highlights() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ASResponse::clear_highlights() {
  if (highlights_ != &::google::protobuf::internal::kEmptyString) {
    highlights_->clear();
  }
  clear_has_highlights();
}
inline const ::std::string& ASResponse::highlights() const {
  return *highlights_;
}
inline void ASResponse::set_highlights(const ::std::string& value) {
  set_has_highlights();
  if (highlights_ == &::google::protobuf::internal::kEmptyString) {
    highlights_ = new ::std::string;
  }
  highlights_->assign(value);
}
inline void ASResponse::set_highlights(const char* value) {
  set_has_highlights();
  if (highlights_ == &::google::protobuf::internal::kEmptyString) {
    highlights_ = new ::std::string;
  }
  highlights_->assign(value);
}
inline void ASResponse::set_highlights(const char* value, size_t size) {
  set_has_highlights();
  if (highlights_ == &::google::protobuf::internal::kEmptyString) {
    highlights_ = new ::std::string;
  }
  highlights_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASResponse::mutable_highlights() {
  set_has_highlights();
  if (highlights_ == &::google::protobuf::internal::kEmptyString) {
    highlights_ = new ::std::string;
  }
  return highlights_;
}
inline ::std::string* ASResponse::release_highlights() {
  clear_has_highlights();
  if (highlights_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = highlights_;
    highlights_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 expired_amount = 11;
inline bool ASResponse::has_expired_amount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ASResponse::set_has_expired_amount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ASResponse::clear_has_expired_amount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ASResponse::clear_expired_amount() {
  expired_amount_ = 0;
  clear_has_expired_amount();
}
inline ::google::protobuf::int32 ASResponse::expired_amount() const {
  return expired_amount_;
}
inline void ASResponse::set_expired_amount(::google::protobuf::int32 value) {
  set_has_expired_amount();
  expired_amount_ = value;
}

// repeated .lbs.da.openservice.ASDealDetail detail = 12;
inline int ASResponse::detail_size() const {
  return detail_.size();
}
inline void ASResponse::clear_detail() {
  detail_.Clear();
}
inline const ::lbs::da::openservice::ASDealDetail& ASResponse::detail(int index) const {
  return detail_.Get(index);
}
inline ::lbs::da::openservice::ASDealDetail* ASResponse::mutable_detail(int index) {
  return detail_.Mutable(index);
}
inline ::lbs::da::openservice::ASDealDetail* ASResponse::add_detail() {
  return detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASDealDetail >&
ASResponse::detail() const {
  return detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ASDealDetail >*
ASResponse::mutable_detail() {
  return &detail_;
}

// optional string exp_ids = 13;
inline bool ASResponse::has_exp_ids() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ASResponse::set_has_exp_ids() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ASResponse::clear_has_exp_ids() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ASResponse::clear_exp_ids() {
  if (exp_ids_ != &::google::protobuf::internal::kEmptyString) {
    exp_ids_->clear();
  }
  clear_has_exp_ids();
}
inline const ::std::string& ASResponse::exp_ids() const {
  return *exp_ids_;
}
inline void ASResponse::set_exp_ids(const ::std::string& value) {
  set_has_exp_ids();
  if (exp_ids_ == &::google::protobuf::internal::kEmptyString) {
    exp_ids_ = new ::std::string;
  }
  exp_ids_->assign(value);
}
inline void ASResponse::set_exp_ids(const char* value) {
  set_has_exp_ids();
  if (exp_ids_ == &::google::protobuf::internal::kEmptyString) {
    exp_ids_ = new ::std::string;
  }
  exp_ids_->assign(value);
}
inline void ASResponse::set_exp_ids(const char* value, size_t size) {
  set_has_exp_ids();
  if (exp_ids_ == &::google::protobuf::internal::kEmptyString) {
    exp_ids_ = new ::std::string;
  }
  exp_ids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASResponse::mutable_exp_ids() {
  set_has_exp_ids();
  if (exp_ids_ == &::google::protobuf::internal::kEmptyString) {
    exp_ids_ = new ::std::string;
  }
  return exp_ids_;
}
inline ::std::string* ASResponse::release_exp_ids() {
  clear_has_exp_ids();
  if (exp_ids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exp_ids_;
    exp_ids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace openservice
}  // namespace da
}  // namespace lbs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_as_2eproto__INCLUDED
